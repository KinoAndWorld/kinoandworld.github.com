<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kino的自留地</title>
  
  
  <link href="http://kinoandworld.github.io/atom.xml" rel="self"/>
  
  <link href="http://kinoandworld.github.io/"/>
  <updated>2025-10-28T09:07:41.438Z</updated>
  <id>http://kinoandworld.github.io/</id>
  
  <author>
    <name>Kino</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>在末日投递希望--《死亡搁浅2》</title>
    <link href="http://kinoandworld.github.io/2025/10/28/%E5%9C%A8%E6%9C%AB%E6%97%A5%E6%8A%95%E9%80%92%E5%B8%8C%E6%9C%9B-%E3%80%8A%E6%AD%BB%E4%BA%A1%E6%90%81%E6%B5%852%E3%80%8B/"/>
    <id>http://kinoandworld.github.io/2025/10/28/%E5%9C%A8%E6%9C%AB%E6%97%A5%E6%8A%95%E9%80%92%E5%B8%8C%E6%9C%9B-%E3%80%8A%E6%AD%BB%E4%BA%A1%E6%90%81%E6%B5%852%E3%80%8B/</id>
    <published>2025-10-28T09:06:13.000Z</published>
    <updated>2025-10-28T09:07:41.438Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一场电影化的孤独之旅"><a href="#一场电影化的孤独之旅" class="headerlink" title="一场电影化的孤独之旅"></a>一场电影化的孤独之旅</h3><p>《死亡搁浅2》给人的第一印象是震撼，这种震撼源于它极致的视听语言和超现实的剧情表达：</p><ul><li><p>画面表现堪称一绝<br>得益于Decima引擎的画面表现和超越一代的音效和运镜，死亡搁浅2绝对是游戏界最为顶尖的电影化叙事水准，或许没有之一。无论是风雷雨雪沙尘暴，还是星空黄昏初日升。无需光线追踪就能让你在以假乱真的大地上驰骋，要知道游戏大部分时间都是一个类似送快递模拟器这样听起来非常枯燥的玩法，但极致的画面表现和细腻的音乐让这个过程变成一场仿佛置身异国的旅行。说句题外话，我觉得死亡搁浅2其实非常适合应用于VR，希望未来能有机会在虚拟现实中再次踏上这片土地。</p></li><li><p>非常规的剧情表现方式<br>虽然游戏部分剧情的走向给人一种很美的精神状态的感觉，但不得不说还挺对我胃口的。从进入焦油世界的光怪陆离，到游戏高潮处进入冥滩的群魔乱舞，越玩越有一种吃了菌子的奇妙感受，有时候也会怀疑这个地方是不是小岛梦到哪句写哪句，但艺术从来不是循规蹈矩的产物，不得不说，让人眼前一亮。</p></li></ul><h3 id="在废土之上，重建四重“连接”"><a href="#在废土之上，重建四重“连接”" class="headerlink" title="在废土之上，重建四重“连接”"></a>在废土之上，重建四重“连接”</h3><p>回到游戏的主题，我想如果用一个词的表达死亡搁浅的内核，应该是【连接】。<br>在游戏中，你可以无时无刻地感受到这种连接，由表及里。</p><ol><li>国与家[sam connect state]</li></ol><p>山姆·波特·布里吉斯以一己之力，通过一次次艰难的跋涉，将孤立的城市与据点接入开罗尔网络，让分崩离析的美国“村通网”。游戏地图的开拓过程，就是货物与站点不断连接的过程：连点成线，连线成网，最终绘制成一个牢牢系紧的绳结。山姆：“我，为互联网带盐。”</p><ol start="2"><li>人与人[player connect player]<br>在送货途中，你会与无数匿名玩家共享一个世界。你们一同修建道路桥梁，分享装备物资，并为彼此的努力点赞。当你于山穷水尽之际，看到其他玩家“遗落”的载具或搭建的充电桩时，那种雪中送炭的温暖，会让你重新燃起对人性的希望。这种互不打扰却彼此扶持的关系，亦是人与人之间最美妙的距离。</li></ol><ol start="3"><li>心与灵[sam connect npc]<br>这一作更着重表现山姆跟BB（布里吉婴）之间紧密地连接之间紧密的羁绊。他们不仅是物理意义上的“连接”，更在旅途中建立了血脉与心灵的共鸣。同时，山姆在通过送货治愈他人的过程中，也与形形色色的人建立了情感连接，这趟旅程，亦是他自我救赎的旅程。我们能清晰地看到，那个时常迷茫、笨拙甚至悲伤的山姆，并非孤胆英雄，他是在同伴们的托举下一步步走到了最后。众人拾柴火焰高，这其实也是人类与文明延展的缩影。</li></ol><ol start="4"><li>敌与我[sam connect Higgs]<br>尽管希格斯被塑造成了令人憎恶的强大反派，但他与山姆却如同镜像的两面。他们同样孤独、执着、百折不挠，灵魂深植于冥滩。他们是“亚美莉”对现世矛盾态度的两个化身，却背道而驰地奔向了创世与灭世的两个极端。常言道，最了解你的不是朋友，而是敌人。他们之间的对立与连接，让故事的张力更加饱满。（但希格斯是真坏啊，最后打得也是真解气）</li></ol><hr><h3 id="搁浅的世界，不倒的文明"><a href="#搁浅的世界，不倒的文明" class="headerlink" title="搁浅的世界，不倒的文明"></a>搁浅的世界，不倒的文明</h3><p>《死亡搁浅》最令人称道的，是它高超的镜头语言和艺术设计。几乎所有过场动画都达到了电影级别，各种建筑、载具和道具的设计也完美服务于其独特的世界观，酷劲十足。</p><p>更重要的是，在固定的剧情脉络下，游戏给予了玩家极大的自由。你可以选择自己的送货路线，可以暗杀或硬闯，甚至可以通过路标和涂装表达自己的意志。这趟旅程充满了个人选择的印记，也引人深思。</p><p>脆弱的人类能延续下去的唯一路径，就是深刻地连接在一起。文明可以搁浅，但只要人类还能互相理解和扶持，一切就还能重建如初。</p><hr><blockquote><p>“无论如何，请记住，不要停下脚步”。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;一场电影化的孤独之旅&quot;&gt;&lt;a href=&quot;#一场电影化的孤独之旅&quot; class=&quot;headerlink&quot; title=&quot;一场电影化的孤独之旅&quot;&gt;&lt;/a&gt;一场电影化的孤独之旅&lt;/h3&gt;&lt;p&gt;《死亡搁浅2》给人的第一印象是震撼，这种震撼源于它极致的视听语言和超现实的剧</summary>
      
    
    
    
    <category term="林中笔记" scheme="http://kinoandworld.github.io/categories/%E6%9E%97%E4%B8%AD%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="游戏" scheme="http://kinoandworld.github.io/tags/%E6%B8%B8%E6%88%8F/"/>
    
  </entry>
  
  <entry>
    <title>APP内录屏直播的小结</title>
    <link href="http://kinoandworld.github.io/2021/07/20/RecordScreenLiveSummary/"/>
    <id>http://kinoandworld.github.io/2021/07/20/RecordScreenLiveSummary/</id>
    <published>2021-07-20T12:32:10.000Z</published>
    <updated>2025-10-28T09:01:11.518Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>关于ReplayKit，现今苹果开放的能力还十分有限，所以充斥着各种各样的”奇技淫巧“</p></blockquote><h3 id="屏幕录制组件"><a href="#屏幕录制组件" class="headerlink" title="屏幕录制组件"></a>屏幕录制组件</h3><p>近年来，由于娱乐方式的移动化和手游化，手机屏幕录制乃至录屏直播一直都是一个呼声很高的需求。但是由于众所周知苹果的<del>封闭</del>保守，直到iOS10，苹果才陆续开放了<br>直到iOS12，才十分”吝啬“地提供了<code>RPSystemBroadcastPickerView</code>这个应用内发起系统级录屏的功能组件。并且，<code>RPSystemBroadcastPickerView</code>其实只能算是一个Button，需要添加到UIView上并让用户手动点击，然后才会触发真正的录屏控制器。</p><p><code>RPSystemBroadcastPickerView</code>本身只提供了设置preferredExtension和showsMicrophoneButton这俩功能，而且这个按钮本身并不是很美观。因此大多数情况下，我们会用自己的开始按钮，然后隐藏RPSystemBroadcastPickerView，通过给里面的按钮sendAction的方式触发。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">UIView</span> *v <span class="keyword">in</span> <span class="keyword">self</span>.sysBroadcastPicker.subviews) &#123;</span><br><span class="line">    <span class="keyword">if</span> ([v isKindOfClass:[<span class="built_in">UIButton</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        [((<span class="built_in">UIButton</span> *)v) sendActionsForControlEvents:<span class="built_in">UIControlEventAllTouchEvents</span>];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用这种方式，我们可以仿佛是自己的Button调起了系统的录屏广播页面，同时配置好preferredExtension，让可用列表里面显示我们自己的APP。<br>（其实直接去系统组件面板开始录屏也是一样的，但是要确保勾选到自己的APP。</p><h3 id="发起录屏后自动隐藏"><a href="#发起录屏后自动隐藏" class="headerlink" title="发起录屏后自动隐藏"></a>发起录屏后自动隐藏</h3><p>在启动了系统的录屏页面后，我们选中指定的APP，会有一个3秒倒计时，倒计时结束后，我们的BroadcastExtension会收到开始录屏的回调，但是这个时候系统录屏页面并不会自动关闭，也没有提供关闭的方法，需要用户手动点击关闭，但是这样对用户体验不太友好（说好的傻瓜式操作）。那有没有什么另辟蹊径的方法，自然是有的，虽然这其中有一个大坑，这个等下再说。</p><img src="https://i.loli.net/2021/07/20/rjxZnR5PbuLeU8S.png" width="50%" height="50%"><p>上图这个页面在弹出的时候，可以看到这应该是一个系统级的页面，并不依附在我们的APP中，但是更重要的是，我注意到， 这个页面在调起的时候，我们的APP会触发<br><code>- (void)applicationDidEnterBackground:(UIApplication *)application</code> 退到后台的方法。而在点击投屏页面后，会自动关闭并且APP进入前台。<br>然后我有一个大胆的想法，那我们能不能强行激活我们的APP，让我们的APP进入前台呢？<br>首先想到的，自然是最简单的SCHEME方式，我们配置好自己APP的的SCHEME，然后直接用openURL的方式唤醒APP。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 因为系统开播控件会使本APP进入后台，可以用SCHEME唤醒自身 同时可以关闭系统界面</span></span><br><span class="line">[[<span class="built_in">UIApplication</span> sharedApplication] openURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@&quot;XXXX://&quot;</span>] options:@&#123;&#125; completionHandler:^(<span class="built_in">BOOL</span> success) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        <span class="comment">// 如果失败，可以用通知告诉用户单击屏幕关闭</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>试一下，发现It work!<br>看起来非常顺利，然而事情并不简单。</p><h3 id="iOS13-x以下系统中奇怪的调起"><a href="#iOS13-x以下系统中奇怪的调起" class="headerlink" title="iOS13.x以下系统中奇怪的调起"></a>iOS13.x以下系统中奇怪的调起</h3><p>功能开发完成后，在进行多机型的测试中，发现有部分系统会出现无法自动关闭的问题。然后在实际测试中，发现并不是所有系统都是全屏覆盖的方式，在iOS13及以下的系统，在某些机型中会出现另外一种样式的系统录屏页面。（并不准确，因为测试机有限）</p><p>从表现上看，这个页面很像是调用了presentModalViewController的方式进行展示的，而且发现APP也没有退到后台和进入前台，因此我们openURL的方式肯定是不会生效的。<br>连续触发调用两次<code>RPSystemBroadcastPickerView</code>的button，然后出现了以下错误<code> Application tried to present modally an active controller</code>，确认了的确是使用了<code>presentModalViewController</code>的方法。<br>接着通过试验，发现并非是在原本的ViewController上进行的，猜测是使用了一个新的UIWindow。</p><p>但是在打印<code>[UIApplication sharedApplication].windows</code>以及使用Xcode的UI运行时调试，都没有发现这个Window的出现。<br>这window还能隐身不成？<br>最后感谢万能的Reveal，终于发现了它的庐山真面目 —— <code>RPModalPresentationWindow</code>。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Generated by RuntimeBrowser</span></span><br><span class="line"><span class="comment">   Image: /System/Library/Frameworks/ReplayKit.framework/ReplayKit</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RPModalPresentationWindow</span> : <span class="title">UIApplicationRotationFollowingWindow</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)_presentationViewController;</span><br><span class="line">- (<span class="keyword">void</span>)dealloc;</span><br><span class="line">- (<span class="keyword">id</span>)init;</span><br><span class="line">- (<span class="keyword">bool</span>)isInternalWindow;</span><br><span class="line">- (<span class="keyword">id</span>)mainWindow;</span><br><span class="line">- (<span class="keyword">void</span>)presentAlertController:(<span class="keyword">id</span>)arg1 animated:(<span class="keyword">bool</span>)arg2 completion:(<span class="keyword">id</span> <span class="comment">/* block */</span>)arg3;</span><br><span class="line">- (<span class="keyword">void</span>)presentViewController:(<span class="keyword">id</span>)arg1 animated:(<span class="keyword">bool</span>)arg2 completion:(<span class="keyword">id</span> <span class="comment">/* block */</span>)arg3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p><code>RPModalPresentationWindow</code>会直接调用presentViewController，而这个controller就是</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Generated by RuntimeBrowser</span></span><br><span class="line"><span class="comment">   Image: /System/Library/Frameworks/ReplayKit.framework/ReplayKit</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RPBroadcastPickerStandaloneViewController</span> : <span class="title">RPSystemBroadcastPickerViewController</span> </span>&#123;</span><br><span class="line">    &lt;RPSystemBroadcastPickerViewControllerDelegate&gt; * _delegate;</span><br><span class="line">    RPModalPresentationWindow * _presentationWindow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) &lt;RPSystemBroadcastPickerViewControllerDelegate&gt; *delegate;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>).cxx_destruct;</span><br><span class="line">- (<span class="keyword">id</span>)delegate;</span><br><span class="line">- (<span class="keyword">void</span>)dismissAfter:(<span class="keyword">double</span>)arg1;</span><br><span class="line">- (<span class="keyword">void</span>)presentAnimated:(<span class="keyword">bool</span>)arg1 completion:(<span class="keyword">id</span> <span class="comment">/* block */</span>)arg2;</span><br><span class="line">- (<span class="keyword">void</span>)setDelegate:(<span class="keyword">id</span>)arg1;</span><br><span class="line">- (<span class="keyword">void</span>)viewControllerDidFinish;</span><br><span class="line">- (<span class="keyword">void</span>)viewDidDisappear:(<span class="keyword">bool</span>)arg1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>另外，由此可见，UIApplication的getWindows方法里面是会过滤掉到一些系统级的window的。</p><p>言归正传，虽然我们知道了系统是创建了一个<code>RPModalPresentationWindow</code>然后present<code>RPBroadcastPickerStandaloneViewController</code>，但是我们拿不到这个window，又要如何调用dismiss呢。</p><p>这就要用到Objective-C著名的黑科技，方法Swizzle了。<br>其实即使我们不知道上面两个具体的window和controller，我们也可以替换掉全局的present，然后观察所有的vc，也能发现端倪。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIViewController</span> (<span class="title">hack</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)load</span><br><span class="line">&#123;</span><br><span class="line">    SEL orig_present = <span class="keyword">@selector</span>(presentViewController:animated:completion:);</span><br><span class="line">    SEL swiz_present = <span class="keyword">@selector</span>(swiz_presentViewController:animated:completion:);</span><br><span class="line">    [<span class="built_in">UIViewController</span> swizzleMethods:[<span class="keyword">self</span> <span class="keyword">class</span>] originalSelector:orig_present swizzledSelector:swiz_present];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//exchange implementation of two methods</span></span><br><span class="line">+ (<span class="keyword">void</span>)swizzleMethods:(Class)<span class="keyword">class</span> originalSelector:(SEL)origSel swizzledSelector:(SEL)swizSel</span><br><span class="line">&#123;</span><br><span class="line">    Method origMethod = class_getInstanceMethod(<span class="keyword">class</span>, origSel);</span><br><span class="line">    Method swizMethod = class_getInstanceMethod(<span class="keyword">class</span>, swizSel);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//class_addMethod will fail if original method already exists</span></span><br><span class="line">    <span class="built_in">BOOL</span> didAddMethod = class_addMethod(<span class="keyword">class</span>, origSel, method_getImplementation(swizMethod), method_getTypeEncoding(swizMethod));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (didAddMethod) &#123;</span><br><span class="line">        class_replaceMethod(<span class="keyword">class</span>, swizSel, method_getImplementation(origMethod), method_getTypeEncoding(origMethod));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//origMethod and swizMethod already exist</span></span><br><span class="line">        method_exchangeImplementations(origMethod, swizMethod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)swiz_presentViewController:(<span class="built_in">UIViewController</span> *)vc animated:(<span class="built_in">BOOL</span>)animated completion:(<span class="keyword">void</span>(^)(<span class="keyword">void</span>))completion</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ([vc isKindOfClass:<span class="built_in">NSClassFromString</span>(<span class="string">@&quot;RPBroadcastPickerStandaloneViewController&quot;</span>)]) &#123;</span><br><span class="line">        <span class="comment">// 保存这个vc，在适当的时机调用DismissViewController</span></span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span> swiz_presentViewController:vc animated:animated completion:completion];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>重新启动，顺利发现可以被捕获到，然后自然成功地Dismiss关闭了页面，大功告成。</p><h3 id="还有个小完善"><a href="#还有个小完善" class="headerlink" title="还有个小完善"></a>还有个小完善</h3><p>上面的代码其实有个小坑，在无意中发现如果在同一时间连续调用presentViewController方法， 会触发一个系统异常<code>Terminating app due to uncaught exception &#39;NSInvalidArgumentException&#39;, reason: &#39;Application tried to present modally an active controller</code>。<br>其实这也是通用的一个注意点，我们正好可以在这里加上一个判断，可以在全局范围内避免这个问题：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)swiz_presentViewController:(<span class="built_in">UIViewController</span> *)vc animated:(<span class="built_in">BOOL</span>)animated completion:(<span class="keyword">void</span>(^)(<span class="keyword">void</span>))completion</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ([vc isKindOfClass:<span class="built_in">NSClassFromString</span>(<span class="string">@&quot;RPBroadcastPickerStandaloneViewController&quot;</span>)]) &#123;</span><br><span class="line">        <span class="comment">// 保存这个vc，在适当的时机调用DismissViewController</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 只有当前没有presentedViewController的时候才能present 否则可能会</span></span><br><span class="line">    <span class="comment">// Terminating app due to uncaught exception &#x27;NSInvalidArgumentException&#x27;, reason: &#x27;Application tried to present modally an active controller</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.presentedViewController == <span class="literal">nil</span>) &#123;</span><br><span class="line">        [<span class="keyword">self</span> swiz_presentViewController:vc animated:animated completion:completion];</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;关于ReplayKit，现今苹果开放的能力还十分有限，所以充斥着各种各样的”奇技淫巧“&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;屏幕录制组件&quot;&gt;&lt;a href=&quot;#屏幕录制组件&quot; class=&quot;headerlink&quot; title=&quot;屏幕</summary>
      
    
    
    
    <category term="iOS" scheme="http://kinoandworld.github.io/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>Swift多线程读写中的内存竞争问题</title>
    <link href="http://kinoandworld.github.io/2021/04/02/iOS-Thread-Access-Race/"/>
    <id>http://kinoandworld.github.io/2021/04/02/iOS-Thread-Access-Race/</id>
    <published>2021-04-02T07:58:51.000Z</published>
    <updated>2025-10-28T09:01:11.518Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Swift多线程读写中的内存竞争问题"><a href="#Swift多线程读写中的内存竞争问题" class="headerlink" title="Swift多线程读写中的内存竞争问题"></a>Swift多线程读写中的内存竞争问题</h1><h2 id="内存竞争"><a href="#内存竞争" class="headerlink" title="内存竞争"></a>内存竞争</h2><p>首先，我们有一段这样的代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> progressMap: [<span class="type">String</span>: <span class="type">Double</span>] = [:]</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">let</span> accessQueue = <span class="type">DispatchQueue</span>(label: <span class="string">&quot;com.ThreadRWTest&quot;</span>, qos: .<span class="keyword">default</span>, attributes: .concurrent, autoreleaseFrequency: .inherit, target: .<span class="keyword">none</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> idx <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="number">1000</span> &#123;</span><br><span class="line">        accessQueue.async(group: .<span class="keyword">none</span>, qos: .<span class="keyword">default</span>, flags: .assignCurrentContext) &#123; [<span class="keyword">self</span>] <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">let</span> str = <span class="string">&quot;\(idx)&quot;</span></span><br><span class="line">            progressMap[str] = <span class="number">0.0</span></span><br><span class="line">            <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">                <span class="built_in">print</span>(str)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一段很常见的代码，我们创建1000个任务（可以粗略理解为创建1000个子线程，当然系统似乎会控制最大线程数量），异步地给progressMap这个字典赋值（写操作），然后切换到主线程展示（这里直接简化为print）。<br>稍微有点经验的可能一眼就看出了代码的异样：在异步多线程写同一个变量。这是内存异常的罪魁祸首之一。</p><p>我们执行以下，以身试法</p><p><img src="https://i.loli.net/2021/04/01/25yf1hAsrXDRHKI.png" alt="WX20210401-174903@2x.png"></p><p>噢，果然崩溃了。</p><p>但是为什么会崩溃呢？或者说如果想知道崩溃发生的细节该如何调试？</p><p>万幸的是，苹果Xcode已经为我们提供了一个非常简单而强大的工具<em>Thread Sanitizer</em><br>在<code>edit scheme</code>选项卡中，勾选中<code>Diagnostics</code>中的<code>Thread Sanitizer</code></p><p><img src="https://i.loli.net/2021/04/01/RFK1p3dDnaOG75v.jpg" alt="1_kBqRpigF7nwCMBK3H3cGKw.jpeg"></p><p>然后重新运行，可以发现，Xcode会直接在控制台打印出一堆分析日志</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">WARNING: ThreadSanitizer: Swift access race (pid&#x3D;76516)</span><br><span class="line">  Modifying access of Swift variable at 0x7b5c00000350 by thread T9:</span><br><span class="line">    #0 ViewController.progressMap.modify ViewController.swift (ThreadRWTest:x86_64+0x100002f34)</span><br><span class="line">    #1 closure #1 in ViewController.viewDidLoad() ViewController.swift:28 (ThreadRWTest:x86_64+0x1000041ce)</span><br><span class="line">    #2 partial apply for closure #1 in ViewController.viewDidLoad() &lt;compiler-generated&gt; (ThreadRWTest:x86_64+0x1000044e5)</span><br><span class="line">    #3 thunk for @escaping @callee_guaranteed () -&gt; () &lt;compiler-generated&gt; (ThreadRWTest:x86_64+0x1000047a3)</span><br><span class="line">    #4 _dispatch_client_callout &lt;null&gt;:2 (libdispatch.dylib:x86_64+0x39c7)</span><br><span class="line">    #5 _dispatch_client_callout &lt;null&gt;:2 (libdispatch.dylib:x86_64+0x39c7)</span><br><span class="line"></span><br><span class="line">  Previous modifying access of Swift variable at 0x7b5c00000350 by thread T5:</span><br><span class="line">    #0 ViewController.progressMap.modify ViewController.swift (ThreadRWTest:x86_64+0x100002f34)</span><br><span class="line">    #1 closure #1 in ViewController.viewDidLoad() ViewController.swift:28 (ThreadRWTest:x86_64+0x1000041ce)</span><br><span class="line">    #2 partial apply for closure #1 in ViewController.viewDidLoad() &lt;compiler-generated&gt; (ThreadRWTest:x86_64+0x1000044e5)</span><br><span class="line">    #3 thunk for @escaping @callee_guaranteed () -&gt; () &lt;compiler-generated&gt; (ThreadRWTest:x86_64+0x1000047a3)</span><br><span class="line">    #4 _dispatch_client_callout &lt;null&gt;:2 (libdispatch.dylib:x86_64+0x39c7)</span><br><span class="line">    #5 _dispatch_client_callout &lt;null&gt;:2 (libdispatch.dylib:x86_64+0x39c7)</span><br></pre></td></tr></table></figure><p>我们直接打开issue navigation的tab，然后选中runtime，也可以看到相关的线程信息</p><p><img src="https://i.loli.net/2021/04/01/YyU36nKwQhiDsfS.png" alt="WX20210401-173616@2x.png"></p><p>从这张图我们明细可以看到线程3和线程9同时调用了progressMap的modify方法，然后产生了<code>access race</code>问题。</p><h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><p>我们现在大概知道问题发生的原因。<br>那么，遇到这种或者类似的问题应该如何解决呢。</p><p>最简单的做法，我们把写操作隔离开，使用栅栏。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将 progressMap[str] = 0.0 修改为</span></span><br><span class="line">accessQueue.async(group: .<span class="keyword">none</span>, qos: .<span class="keyword">default</span>, flags: .barrier, execute: &#123;</span><br><span class="line">    progressMap[str] = <span class="number">0.0</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>重新运行，确实不会崩溃了<br>想一下barrier的作用，它阻塞了下一个任务，确保之前的任务执行完毕再执行下一个任务。<br>这里就起到了一个确保写操作是独占的，避免了多个线程同时修改一块内存的隐患。</p><h2 id="变量加锁"><a href="#变量加锁" class="headerlink" title="变量加锁"></a>变量加锁</h2><p>值得注意的是，如果打算通过直接给map变量加锁的话，我们可以想到这样的方式：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">objc_sync_enter(progressMap)</span><br><span class="line">progressMap[str] = <span class="number">0.0</span></span><br><span class="line">objc_sync_exit(progressMap)</span><br></pre></td></tr></table></figure><p>然而遗憾的是，这是不可行的，实际运行还是会崩溃。<br>通过一些<a href="https://stackoverflow.com/questions/35084754/objc-sync-enter-objc-sync-exit-not-working-with-dispatch-queue-priority-low">资料</a>，我注意到这里的关键是因为，在swift中，map是值类型的。<br>因此，objc_sync_enter(progressMap)传递的只是progressMap的拷贝，相当于这些代码完全没生效！<br>（如果是引用类型应该是可行的，但是objc_sync_enter使用递归锁性能相对较差，建议也少用）</p><p>如果想使用锁可以尝试直接使用<code>pthread_mutex_t</code>:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mutex = pthread_mutex_t()</span><br><span class="line">pthread_mutex_init(&amp;(<span class="keyword">self</span>.mutex), <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> start = <span class="type">CACurrentMediaTime</span>()</span><br><span class="line"><span class="keyword">for</span> idx <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="number">500</span> &#123;</span><br><span class="line">    accessQueue.async(group: .<span class="keyword">none</span>, qos: .<span class="keyword">default</span>, flags: .assignCurrentContext) &#123; [<span class="keyword">self</span>] <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">let</span> str = <span class="string">&quot;\(idx)&quot;</span></span><br><span class="line">        <span class="keyword">let</span> retCode = pthread_mutex_trylock(&amp;mutex)</span><br><span class="line">        <span class="keyword">if</span> retCode == <span class="number">0</span> &#123;</span><br><span class="line">            progressMap[str] = <span class="number">0.0</span></span><br><span class="line">            pthread_mutex_unlock(&amp;mutex)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者使用一个自己创建的串行队列也可以达到线程同步的效果。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>多线程同时读写同一变量可能导致内存问题</li><li>使用<code>Thread Sanitizer</code>排查和分析</li><li>使用<code>barrier</code>或者<code>pthread_mutex_t</code>线程锁或者串行队列都可以解锁或避免这个问题</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Swift多线程读写中的内存竞争问题&quot;&gt;&lt;a href=&quot;#Swift多线程读写中的内存竞争问题&quot; class=&quot;headerlink&quot; title=&quot;Swift多线程读写中的内存竞争问题&quot;&gt;&lt;/a&gt;Swift多线程读写中的内存竞争问题&lt;/h1&gt;&lt;h2 id=&quot;内</summary>
      
    
    
    
    <category term="iOS" scheme="http://kinoandworld.github.io/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS突发奇想编程系列之 图片拼图(4)</title>
    <link href="http://kinoandworld.github.io/2021/03/23/iOS-Photo-Puzzle-4/"/>
    <id>http://kinoandworld.github.io/2021/03/23/iOS-Photo-Puzzle-4/</id>
    <published>2021-03-23T10:28:01.000Z</published>
    <updated>2025-10-28T09:01:11.518Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第四篇-完成度判断"><a href="#第四篇-完成度判断" class="headerlink" title="第四篇 完成度判断"></a>第四篇 完成度判断</h2><p>经过前面的努力，我们现在已经完成了整个拼图的大概框架。在这篇中，我们再稍微完善和补充一下细节，把整个流程做一个总结。</p><p>首先，我们用一个数据模型，绑定图片和对应的位置</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PieceDataModel</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> loc: <span class="type">CGPoint</span> = .zero</span><br><span class="line">    <span class="keyword">var</span> image = <span class="type">UIImage</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在开始拖拽碎片的时候，我们追踪这个model，然后在移动结束后，判断当前拖拽碎片与终点位置是否一致，如果一致，那么说明这个方块已经正确移动到了目标。</p><p>这里，我们可以做一个”锁定“的操作，便于简化后续的操作。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拼图摆放记录 n*n</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> completeStates: [[<span class="type">Int</span>]] = []</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在放置碎片完成后调用</span></span><br><span class="line"><span class="keyword">self</span>.checkAdapterBindCorrect(adapter: adapter)</span><br><span class="line"><span class="comment">// 判断游戏是否结束</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">self</span>.checkAllComplete() &#123;</span><br><span class="line">    <span class="keyword">self</span>.showCompleteAlert()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 判断当前绑定是否正确</span></span><br><span class="line"><span class="comment">/// - Parameter adapter: PieceDragableAdapter</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">checkAdapterBindCorrect</span><span class="params">(adapter: PieceDragableAdapter)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 判断是否落在了正确的格子</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> dragingLoc = <span class="keyword">self</span>.dragingModel?.loc, dragingLoc.equalTo(adapter.bindPt) &#123;</span><br><span class="line">        adapter.bindView?.alpha = <span class="number">1.0</span></span><br><span class="line">        <span class="comment">// 如果正确 则锁定</span></span><br><span class="line">        completeStates[<span class="type">Int</span>(adapter.bindPt.x)][<span class="type">Int</span>(adapter.bindPt.y)] = <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        adapter.bindView?.alpha = <span class="number">0.5</span></span><br><span class="line">        completeStates[<span class="type">Int</span>(adapter.bindPt.x)][<span class="type">Int</span>(adapter.bindPt.y)] = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们拖拽碎片到一个已经”锁定”的格子上时，则直接return。<br>以及当我们在一个已经”锁定”的格子上拖拽时，也直接return。<br>这样可以保障当一个碎片已经正确移动时，我们便可以更好专注于未完成的碎片。</p><p>同时，得益于<code>completeStates</code>，我们只需要判断当<code>completeStates</code>的所有元素都为1时，拼图就全部完成了。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">checkAllComplete</span><span class="params">()</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> list <span class="keyword">in</span> completeStates &#123;</span><br><span class="line">        <span class="keyword">for</span> state <span class="keyword">in</span> list &#123;</span><br><span class="line">            <span class="keyword">if</span> state == <span class="number">0</span> &#123; <span class="keyword">return</span> <span class="literal">false</span> &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">showCompleteAlert</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> alert = <span class="type">UIAlertController</span>(title: <span class="string">&quot;恭喜🎇&quot;</span>, message: <span class="string">&quot;拼图已完成&quot;</span>, preferredStyle: .alert)</span><br><span class="line">    alert.addAction(<span class="type">UIAlertAction</span>(title: <span class="string">&quot;👌&quot;</span>, style: .<span class="keyword">default</span>, handler: &#123; [<span class="keyword">unowned</span> <span class="keyword">self</span>] <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">self</span>.navigationController?.popViewController(animated: <span class="literal">true</span>)</span><br><span class="line">    &#125;))</span><br><span class="line">    present(alert, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们运行一下，看一下最终的效果。</p><p><img src="https://i.loli.net/2021/03/23/jxb1ZyGQ3nKlUEa.png" alt="IMG_5235.PNG"></p><p>补全最后一块拼图后：</p><p><img src="https://i.loli.net/2021/03/23/ZSmrUbtNIJqfCy9.png" alt="IMG_5236.PNG"></p><p>大功告成！</p><p>最后，项目的所有代码我放会在GitHub上，作一个阶段性的成果😆<br><a href="https://github.com/KinoAndWorld/PuzzleDemo">https://github.com/KinoAndWorld/PuzzleDemo</a></p><hr><p>写在后面：<br>虽然现在项目告一段落，但是还有非常多需要完善和扩展的空间。比如UI的完善，碎片的打乱，流程的规范，逻辑的补完。</p><p>但毫无疑问的是，这是一次非常有趣的尝试。也让我学习到了许多，吾生有崖而知无涯，共勉之。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第四篇-完成度判断&quot;&gt;&lt;a href=&quot;#第四篇-完成度判断&quot; class=&quot;headerlink&quot; title=&quot;第四篇 完成度判断&quot;&gt;&lt;/a&gt;第四篇 完成度判断&lt;/h2&gt;&lt;p&gt;经过前面的努力，我们现在已经完成了整个拼图的大概框架。在这篇中，我们再稍微完善和补</summary>
      
    
    
    
    <category term="iOS" scheme="http://kinoandworld.github.io/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS突发奇想编程系列之 图片拼图(3)</title>
    <link href="http://kinoandworld.github.io/2021/03/23/iOS-Photo-Puzzle-3/"/>
    <id>http://kinoandworld.github.io/2021/03/23/iOS-Photo-Puzzle-3/</id>
    <published>2021-03-23T02:46:55.000Z</published>
    <updated>2025-10-28T09:01:11.518Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第三篇-拼接和吸附（手势处理"><a href="#第三篇-拼接和吸附（手势处理" class="headerlink" title="第三篇 拼接和吸附（手势处理"></a>第三篇 拼接和吸附（手势处理</h2><p>有了碎片之后，我们可以尝试构造一个新的页面，在这个页面中，我们分为两个部分，碎片放置区，和拼图框区。<br>琐碎的页面布局和数据粗略完成以下，变成了图下，我们在拼图框直接放个原图的浅透明，当作提示和区域说明。<br><img src="https://i.loli.net/2021/03/23/c1CISfVKGpRsPlj.png" alt="piece-arrange.png"></p><p>然后，我们要做的，就是把下方区域的碎片通过手势拖拽到上方区域中。<br>首先想到的是组合UILongPressGesture和PanGesture等组合手势，但是突然发现或许可以直接使用iOS11新推出的Drag&amp;Drog手势来处理。正好学习一下新的技术应用。</p><p><img src="https://i.loli.net/2021/03/23/AGqg9of75LQSC8H.png" alt="1501122-dc430560f58ee325.png"></p><p>虽然其实这个手势更大的用途是在于APP之内的数据传输，但是我们可以稍微利用一下，</p><p>简单地，我们给下方的listview（这里我用collectionView）添加一下手势</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">collectionView.dragInteractionEnabled = <span class="literal">true</span></span><br><span class="line">collectionView.dragDelegate = <span class="keyword">self</span></span><br></pre></td></tr></table></figure><p>然后简单添加处理delegate</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">PuzzlePlayController</span>: <span class="title">UICollectionViewDragDelegate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(<span class="number">_</span> collectionView: UICollectionView, itemsForBeginning session: UIDragSession, at indexPath: IndexPath)</span></span> -&gt; [<span class="type">UIDragItem</span>] &#123;</span><br><span class="line">        <span class="keyword">let</span> itemProvider = <span class="type">NSItemProvider</span>(object: pieceImages[indexPath.item])</span><br><span class="line">        <span class="keyword">let</span> item = <span class="type">UIDragItem</span>(itemProvider: itemProvider)</span><br><span class="line">        <span class="keyword">self</span>.dragIndexPath = indexPath</span><br><span class="line">        <span class="keyword">return</span> [item]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(<span class="number">_</span> collectionView: UICollectionView, dragSessionIsRestrictedToDraggingApplication session: UIDragSession)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(<span class="number">_</span> collectionView: UICollectionView, dragSessionAllowsMoveOperation session: UIDragSession)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候，长按collection中的拼图碎片，就可以成功抓取碎片，系统也会自动加上一些效果<br><img src="https://i.loli.net/2021/03/23/xV9qhBfToHsc8bA.png" alt="piece-drag.png"></p><p>接着，我们直接实现view接收drog手势的处理</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">PuzzlePlayController</span>: <span class="title">UIDropInteractionDelegate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">dropInteraction</span><span class="params">(<span class="number">_</span> interaction: UIDropInteraction, canHandle session: UIDropSession)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">dropInteraction</span><span class="params">(<span class="number">_</span> interaction: UIDropInteraction, performDrop session: UIDropSession)</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> pt = session.location(<span class="keyword">in</span>: <span class="keyword">self</span>.view)</span><br><span class="line">        session.loadObjects(ofClass: <span class="type">UIImage</span>.<span class="keyword">self</span>) &#123; (image) <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> img = image.first <span class="keyword">as</span>? <span class="type">UIImage</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">self</span>.puzzleContainerView.frame.<span class="built_in">contains</span>(pt) &#123;</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;在区域内&quot;</span>)</span><br><span class="line">                <span class="keyword">let</span> imageV = <span class="type">UIImageView</span>(image: img)</span><br><span class="line">                imageV.frame = <span class="keyword">self</span>.currentHighlightRect(oriPt: pt)</span><br><span class="line">                <span class="keyword">self</span>.puzzleContainerView.addSubview(imageV)</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">let</span> adapter = <span class="type">PieceDragableAdapter</span>(view: imageV, image: img)</span><br><span class="line">                <span class="keyword">self</span>.pieceAdapters.append(adapter)</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">let</span> dragIdx = <span class="keyword">self</span>.dragIndexPath?.item &#123;</span><br><span class="line">                    <span class="keyword">self</span>.collectionView.performBatchUpdates &#123;</span><br><span class="line">                        <span class="keyword">self</span>.pieceImages.remove(at: dragIdx)</span><br><span class="line">                        <span class="keyword">self</span>.collectionView.deleteItems(at: [<span class="type">IndexPath</span>(item: dragIdx, section: <span class="number">0</span>)])</span><br><span class="line">                    &#125; completion: &#123; (done) <span class="keyword">in</span></span><br><span class="line">                        </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;不在区域内&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">dropInteraction</span><span class="params">(<span class="number">_</span> interaction: UIDropInteraction, sessionDidUpdate session: UIDropSession)</span></span> -&gt; <span class="type">UIDropProposal</span> &#123;</span><br><span class="line">        <span class="comment">// Propose to the system to copy the item from the source app</span></span><br><span class="line">        <span class="keyword">let</span> pt = session.location(<span class="keyword">in</span>: <span class="keyword">self</span>.view)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;ori pt = \(pt)&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.puzzleContainerView.frame.<span class="built_in">contains</span>(pt) &#123;</span><br><span class="line">            <span class="keyword">let</span> retPt = view.convert(pt, to: <span class="keyword">self</span>.puzzleContainerView)</span><br><span class="line">            <span class="built_in">print</span>(retPt)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 确定在哪个方格</span></span><br><span class="line">            <span class="keyword">let</span> rectWidth = puzzleContainerView.frame.width / <span class="type">CGFloat</span>(rowCount)</span><br><span class="line">            <span class="keyword">let</span> column = floor(retPt.x / rectWidth)</span><br><span class="line">            <span class="keyword">let</span> row = floor(retPt.y / rectWidth)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">let</span> idx = <span class="type">Int</span>(column + row * <span class="type">CGFloat</span>(rowCount))</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;当前落在格子\(column)-\(row)， 对应方格-\(idx)&quot;</span>)</span><br><span class="line">            </span><br><span class="line">            lastHightlightFV?.isHidden = <span class="literal">true</span></span><br><span class="line">            tipsFrames[idx].isHidden = <span class="literal">false</span></span><br><span class="line">            lastHightlightFV = tipsFrames[idx]</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="type">UIDropProposal</span>(operation: .move)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里省略了<code>一点点</code>细节，为了方便处理和提升交互，我们在框内添加了N*N个”边框View”，当拼图移动到对应的区域内，则显示边框，否则隐藏。松开后，同样判断当前移动坐落在哪个格子内，然后放置。</p><p>初始化边框代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">setupPuzzleRect</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> pieceSize: <span class="type">CGFloat</span> = <span class="number">300.0</span> / <span class="type">CGFloat</span>(rowCount)</span><br><span class="line">    <span class="keyword">for</span> r <span class="keyword">in</span> <span class="number">0</span>..&lt;rowCount &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">c</span> <span class="keyword">in</span> <span class="number">0</span>..&lt;rowCount &#123;</span><br><span class="line">            <span class="keyword">let</span> frameV = <span class="type">UIView</span>(frame: <span class="type">CGRect</span>(x: <span class="type">CGFloat</span>(<span class="built_in">c</span>) * pieceSize,</span><br><span class="line">                                                y: <span class="type">CGFloat</span>(r) * pieceSize,</span><br><span class="line">                                                width: pieceSize, height: pieceSize))</span><br><span class="line">            frameV.layer.borderWidth = <span class="number">4</span></span><br><span class="line">            frameV.layer.borderColor = <span class="type">UIColor</span>.lightGray.cgColor</span><br><span class="line">            </span><br><span class="line">            frameV.isHidden = <span class="literal">true</span></span><br><span class="line">            tipsFrames.append(frameV)</span><br><span class="line">            </span><br><span class="line">            puzzleContainerView.addSubview(frameV)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>移动到对应方块上的高亮边框：<br><img src="https://i.loli.net/2021/03/23/JLyXhkcfAeFlr9T.png" alt="piece-drag-in.png"></p><p>同时，我们在创建碎片摆在”棋盘”时，也要同时给碎片View增加拖拽手势，方便二次移动。我们新建一个<code>PieceDragableAdapter</code>来管理：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PieceDragableAdapter</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> bindView: <span class="type">UIView?</span></span><br><span class="line">    <span class="keyword">var</span> bindImage = <span class="type">UIImage</span>()</span><br><span class="line">    <span class="keyword">var</span> bindPt: <span class="type">CGPoint</span> = .zero</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> isVaild: <span class="type">Bool</span> = <span class="literal">true</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(view: <span class="type">UIView</span>, image: <span class="type">UIImage</span>, loc: <span class="type">CGPoint</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">self</span>.bindView = view</span><br><span class="line">        <span class="keyword">self</span>.bindImage = image</span><br><span class="line">        <span class="keyword">self</span>.bindPt = loc</span><br><span class="line">        </span><br><span class="line">        commonInit()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">commonInit</span><span class="params">()</span></span> &#123;</span><br><span class="line">        bindView?.isUserInteractionEnabled = <span class="literal">true</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> dragInteract = <span class="type">UIDragInteraction</span>(delegate: <span class="keyword">self</span>)</span><br><span class="line">        bindView?.addInteraction(dragInteract)</span><br><span class="line">        dragInteract.isEnabled = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">PieceDragableAdapter</span>: <span class="title">UIDragInteractionDelegate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">dragInteraction</span><span class="params">(<span class="number">_</span> interaction: UIDragInteraction, itemsForBeginning session: UIDragSession)</span></span> -&gt; [<span class="type">UIDragItem</span>] &#123;</span><br><span class="line">        <span class="keyword">if</span> !isVaild &#123; <span class="keyword">return</span> [] &#125;</span><br><span class="line">        <span class="keyword">let</span> itemProvider = <span class="type">NSItemProvider</span>(object: bindImage)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> item = <span class="type">UIDragItem</span>(itemProvider: itemProvider)</span><br><span class="line">        session.localContext = (<span class="string">&quot;Piece-Frame&quot;</span>, <span class="keyword">self</span>.bindPt)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 半透明化原图</span></span><br><span class="line">        <span class="keyword">self</span>.bindView?.alpha = <span class="number">0.5</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> [item]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">dragInteraction</span><span class="params">(<span class="number">_</span> interaction: UIDragInteraction, sessionAllowsMoveOperation session: UIDragSession)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">dragInteraction</span><span class="params">(<span class="number">_</span> interaction: UIDragInteraction, session: UIDragSession, willEndWith operation: UIDropOperation)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再扩展一下<code>func dropInteraction(_ interaction: UIDropInteraction, performDrop session: UIDropSession)</code>方法，让其同时处理来自棋盘内部的拖拽</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断来源 如果是移动铺面的</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> context = session.localDragSession?.localContext <span class="keyword">as</span>? (<span class="type">String</span>, <span class="type">CGPoint</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> fromPt = context.<span class="number">1</span></span><br><span class="line">        <span class="comment">// 移动到新方块</span></span><br><span class="line">        <span class="keyword">let</span> newFrame = <span class="keyword">self</span>.currentHighlightRect(oriPt: pt)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> adapter = <span class="keyword">self</span>.adapterByLoc(pt: fromPt) &#123;</span><br><span class="line">            adapter.bindView?.frame = newFrame</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 更新pt</span></span><br><span class="line">            adapter.bindPt = <span class="keyword">self</span>.lastHighlightPt</span><br><span class="line">            <span class="comment">// 隐藏方块</span></span><br><span class="line">            <span class="keyword">self</span>.lastHightlightFV?.isHidden = <span class="literal">true</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">self</span>.checkAdapterBindCorrect(adapter: adapter)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第三篇-拼接和吸附（手势处理&quot;&gt;&lt;a href=&quot;#第三篇-拼接和吸附（手势处理&quot; class=&quot;headerlink&quot; title=&quot;第三篇 拼接和吸附（手势处理&quot;&gt;&lt;/a&gt;第三篇 拼接和吸附（手势处理&lt;/h2&gt;&lt;p&gt;有了碎片之后，我们可以尝试构造一个新的页面，</summary>
      
    
    
    
    <category term="iOS" scheme="http://kinoandworld.github.io/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS突发奇想编程系列之 图片拼图(2)</title>
    <link href="http://kinoandworld.github.io/2021/03/23/iOS-Photo-Puzzle-2/"/>
    <id>http://kinoandworld.github.io/2021/03/23/iOS-Photo-Puzzle-2/</id>
    <published>2021-03-23T02:45:08.000Z</published>
    <updated>2025-10-28T09:01:11.518Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第二篇-分析拼图分布"><a href="#第二篇-分析拼图分布" class="headerlink" title="第二篇 分析拼图分布"></a>第二篇 分析拼图分布</h2><p>接上文，我们的拼图切割已经初步实现了。不过我们注意到，我们现在是需要一个一个去描述拼图碎片的状态，这样非常容易出错而且不灵活，更重要的是，如果我们需要构造一个10x10的拼图，那我们需要创建100个PieceSlicer并且分别描述好4个边的情况，So，这是非常不人道的。</p><p>因此我们需要写一个简单的碎片生成算法。<br>我们首先需要明确一下，一个拼图的碎片，需要遵循的约束，然后大致提炼出以下几条规则：</p><ul><li>规则1：最外层的边都是平面</li><li>规则2：没有约束的情况下随机凹凸</li><li>规则3：一个碎片凹或凸的边不能超过3个</li><li>规则4：相邻碎片的凹凸需要契合<br>最后，遇事不决，暴力穷举。<br>我们遍历NxN个碎片，然后逐一检查边界与契合情况，分别赋值，剩余的可凹可凸我们随机赋值即可。</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// n x n 的方阵</span></span><br><span class="line"><span class="keyword">var</span> <span class="built_in">map</span>: [[<span class="type">PieceSlicer</span>]] = []</span><br><span class="line"></span><br><span class="line"><span class="comment">// 规则1：最外层的边都是平面</span></span><br><span class="line"><span class="comment">// 规则2：没有约束的情况下随机凹凸</span></span><br><span class="line"><span class="comment">// 规则3：一个碎片凹或凸的边不能超过2个</span></span><br><span class="line"><span class="comment">// 规则4：相邻碎片的凹凸需要契合</span></span><br><span class="line"><span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">construct</span><span class="params">()</span></span> -&gt; [<span class="type">PieceSlicer</span>] &#123;</span><br><span class="line">    <span class="keyword">var</span> pieceList: [<span class="type">PieceSlicer</span>] = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> raduis: <span class="type">CGFloat</span> = pieceFillRadius</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;row &#123;</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">0</span>..&lt;row &#123;</span><br><span class="line">            <span class="keyword">var</span> slicer = <span class="type">PieceSlicer</span>(<span class="keyword">left</span>: .<span class="keyword">none</span>, top: .<span class="keyword">none</span>, <span class="keyword">right</span>: .<span class="keyword">none</span>, bottom: .<span class="keyword">none</span>)</span><br><span class="line">            slicer.holeRadius = raduis</span><br><span class="line">            <span class="keyword">var</span> lineBox: [<span class="type">PieceSlicer</span>.<span class="type">PathDrawType</span>] = [.inner, .outside]</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 根据前置位 匹配凹凸类型</span></span><br><span class="line">            <span class="keyword">if</span> j == <span class="number">0</span> &#123;</span><br><span class="line">                slicer.leftDraw = .line</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 左边有方块 直接取反</span></span><br><span class="line">                <span class="keyword">let</span> leftSilce = <span class="built_in">map</span>[i][j-<span class="number">1</span>]</span><br><span class="line">                slicer.leftDraw = leftSilce.rightDraw.oppose</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> j == row - <span class="number">1</span> &#123; slicer.rightDraw = .line &#125;</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">                slicer.topDraw = .line</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> topSilce = <span class="built_in">map</span>[i-<span class="number">1</span>][j]</span><br><span class="line">                slicer.topDraw = topSilce.bottomDraw.oppose</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> i == row - <span class="number">1</span> &#123; slicer.bottomDraw = .line &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 填充剩余边</span></span><br><span class="line">            slicer.randomSetDirections(box: &amp;lineBox)</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">print</span>(slicer.description())</span><br><span class="line">            pieceList.append(slicer)</span><br><span class="line">            <span class="built_in">map</span>[i][j] = slicer</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pieceList</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>另外需要注意的是，我们的拼图碎片大小也与碎片数量呈反比，所以我们前面提到的凹凸半径，需要根据碎片数量或者碎片大小进行动态调整。</p><p>好了，我们调整一下布局代码，重新生成。<br>我们分别试一试4x4个碎片 和 6x6个碎片的效果：</p><p>N=4<br><img src="https://i.loli.net/2021/03/23/oCJ4wQNTAbs8Sgp.png" alt="piece-n4.png"></p><p>N=6<br><img src="https://i.loli.net/2021/03/23/iKda1wpg2FeA5Nt.png" alt="piece-n6.png"></p><p>鹅妹子嘤！看起来还不错~<br>拼图的碎片生成到此暂时告一段落，接下来我们尝试把生成的碎片打乱并且添加手势，实现游戏的拼图过程。</p><p><code>另外，由于当前碎片生成算法显而易见地低效（O(n²)），在生成的碎片越多的情况下效率越低，因此如果需要大量生成拼图碎片，需要优化算法或者选择其他算法。</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第二篇-分析拼图分布&quot;&gt;&lt;a href=&quot;#第二篇-分析拼图分布&quot; class=&quot;headerlink&quot; title=&quot;第二篇 分析拼图分布&quot;&gt;&lt;/a&gt;第二篇 分析拼图分布&lt;/h2&gt;&lt;p&gt;接上文，我们的拼图切割已经初步实现了。不过我们注意到，我们现在是需要一个一个</summary>
      
    
    
    
    <category term="iOS" scheme="http://kinoandworld.github.io/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS突发奇想编程系列之 图片拼图(1)</title>
    <link href="http://kinoandworld.github.io/2021/03/22/iOS-Photo-Puzzle/"/>
    <id>http://kinoandworld.github.io/2021/03/22/iOS-Photo-Puzzle/</id>
    <published>2021-03-22T03:36:36.000Z</published>
    <updated>2025-10-28T09:01:11.518Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一篇-分析碎片切图"><a href="#第一篇-分析碎片切图" class="headerlink" title="第一篇 分析碎片切图"></a>第一篇 分析碎片切图</h2><p>拼图是一个老少咸宜的益智游戏，相信大家都玩过。有一天我突然看到街上的自定义照片的拼图，想到我能不能也做一个能自动把一张图片分割成拼图碎片，甚至还能手动拼回来的APP呢。<br>听起来有点意思，闲暇之余，我也稍微认真思考了一下……</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>首先，我们看下一个完整的拼图长啥样</p><p><img src="https://i.loli.net/2021/03/22/iTBjAXPytmWKv1p.jpg" alt="stock-vector-jigsaw-icon-241085644.jpg"></p><p>可以看到，即使在这个相当简单的拼图中，拼图碎片的种类也非常多，我找了另一张图，可稍管中窥豹。<br><img src="https://i.loli.net/2021/03/22/r1KGBezn2Y7PmaM.jpg" alt="stock-vector-set-of-black-and-white-puzzle-pieces-isolated-on-white-background-vector-illustration-1171424941.jpg"></p><p>从这张图中我们发现，一个拼图碎片其实就是一张大图通过比例均等切割后的矩形，再构造【凹】与【凸】两种形态，由此形成的排列组合。</p><p>因为是矩形，所以是4个面，而每个面都有3种状态，<code>凸</code>、<code>凹</code>和<code>平</code>，<br>一共是3的4次方。</p><p>当然，在实际拼图中，我们会制订一些规则，实际的碎片样式会少很多。这个是后话，暂且不表，我们先来研究一下，在iOS中如何切出不规则的拼图碎片。</p><h4 id="拼图切割"><a href="#拼图切割" class="headerlink" title="拼图切割"></a>拼图切割</h4><p>第一步，我们先将大图平均分成多个小图。<br>这一步非常简单，我们只需要写一个扩展，就能将任意的一个view通过给定的frame裁剪出一个新的UIImage。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIView</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">asImage</span><span class="params">(rect: CGRect)</span></span> -&gt; <span class="type">UIImage</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> renderer = <span class="type">UIGraphicsImageRenderer</span>(bounds: rect)</span><br><span class="line">        <span class="keyword">return</span> renderer.image &#123; rendererContext <span class="keyword">in</span></span><br><span class="line">            layer.render(<span class="keyword">in</span>: rendererContext.cgContext)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看起来很简单，但是，这里有一个点我们需要注意的是，例如我们需要切割2x2的拼图方块，我们想当然地将图片切成宽高/2的4张图片，但是不要忘记我们的拼图是包括<code>凸</code>的形态，倘若使用这种均分的切割，无法很好地对碎片进行统一的处理。因此，我们会加大裁切的区域，我们以’凸出的长度’为半径，扩展截图区域，大概如图所示：<br><img src="https://i.loli.net/2021/03/22/q7h3guvDPxpTURM.png" alt="WX20210119-170425@2x.png"></p><p>示例代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> canverWidth: <span class="type">CGFloat</span> = imageView.frame.width / <span class="number">2.0</span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">for</span> idx <span class="keyword">in</span> <span class="number">0</span>...<span class="number">3</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> row: <span class="type">Int</span> = idx / <span class="number">2</span></span><br><span class="line">    <span class="keyword">let</span> column: <span class="type">Int</span> = idx % <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> image = imageView.asImage(rect: <span class="type">CGRect</span>(x: canverWidth * <span class="type">CGFloat</span>(column) - <span class="type">PieceConfigure</span>.holeRadius * <span class="number">2</span>,</span><br><span class="line">                                                y: canverWidth * <span class="type">CGFloat</span>(row) - <span class="type">PieceConfigure</span>.holeRadius * <span class="number">2</span>,</span><br><span class="line">                                                width: canverWidth + <span class="type">PieceConfigure</span>.holeRadius * <span class="number">4</span>,</span><br><span class="line">                                                height: canverWidth + <span class="type">PieceConfigure</span>.holeRadius * <span class="number">4</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> imageV = <span class="type">UIImageView</span>(image: image)</span><br><span class="line">    imageV.backgroundColor = .lightGray</span><br><span class="line">    imageV.contentMode = .scaleAspectFill</span><br><span class="line">    view.addSubview(imageV)</span><br><span class="line">    </span><br><span class="line">    imageV.frame = <span class="type">CGRect</span>(x: (canverWidth + <span class="number">40</span>) * <span class="type">CGFloat</span>(column) + <span class="number">30</span>, y: (canverWidth + <span class="number">40</span>) * <span class="type">CGFloat</span>(row) + <span class="number">500</span>,</span><br><span class="line">                            width: imageView.frame.width / <span class="number">2.0</span> + <span class="type">PieceConfigure</span>.holeRadius * <span class="number">2</span>,</span><br><span class="line">                            height: imageView.frame.height / <span class="number">2.0</span> + <span class="type">PieceConfigure</span>.holeRadius * <span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/03/22/4E76krn3TGDlfhe.png" alt="rect-slice.png"></p><p>可以看到，这个时候我们切的4张图，是相互重叠且带有边距的。这为我们下一步的拼图抠图，做足了准备。</p><h4 id="凹凸不规则切割"><a href="#凹凸不规则切割" class="headerlink" title="凹凸不规则切割"></a>凹凸不规则切割</h4><p>根据前文所说我们看到，我们已经成功实现了一张大图的多图分割，并且应对各种情况留了裁切区域。前面我们也说过，每个面只有3种情况，平面、凹和凸，平面就是什么也不用做，我们主要看下凹和凸的实现。</p><p>我们可以简单地用一个圆形的图形运算来模拟这个过程：</p><p><img src="https://i.loli.net/2021/03/22/lIWCvdJZNjLEczT.png" alt="WX20210120-164821@2x.png"></p><p>凹：通过对矩形和圆形进行顶层交集即可</p><p><img src="https://i.loli.net/2021/03/22/yj7KF6NC5sbzWwt.png" alt="WX20210120-164831@2x.png"></p><p>凸：通过图形并集可得</p><p><img src="https://i.loli.net/2021/03/22/kYuUiLnbaSpTWAK.png" alt="WX20210120-164849@2x.png"></p><p>在iOS的实现中，我通过直接使用UIBezierPath编辑路径，使用绘制圆弧的方式达到效果。<br>以一条边为例，绘制的代码如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> path = <span class="type">UIBezierPath</span>()</span><br><span class="line">path.move(to: <span class="type">CGPoint</span>(x: startX, y: startY))</span><br><span class="line"></span><br><span class="line"><span class="comment">// top</span></span><br><span class="line">path.addLine(to: <span class="type">CGPoint</span>(x: (width + startX) / <span class="number">2</span>  - <span class="type">PieceConfigure</span>.holeRadius, y: startY))</span><br><span class="line"><span class="keyword">if</span> topDraw == .outside &#123;</span><br><span class="line">    path.addArc(withCenter: <span class="type">CGPoint</span>(x: (width+startX) / <span class="number">2</span>, y: startY - <span class="type">PieceConfigure</span>.holeRadius),</span><br><span class="line">                radius: <span class="type">PieceConfigure</span>.holeRadius,</span><br><span class="line">                startAngle: <span class="type">CGFloat</span>(<span class="number">180.0</span>).toRadians(),</span><br><span class="line">                endAngle: <span class="type">CGFloat</span>(<span class="number">0.0</span>).toRadians(),</span><br><span class="line">                clockwise: <span class="literal">true</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> topDraw == .inner &#123;</span><br><span class="line">    path.addArc(withCenter: <span class="type">CGPoint</span>(x: (width+startX) / <span class="number">2</span>, y: startY + <span class="type">PieceConfigure</span>.holeRadius),</span><br><span class="line">                radius: <span class="type">PieceConfigure</span>.holeRadius,</span><br><span class="line">                startAngle: <span class="type">CGFloat</span>(<span class="number">180.0</span>).toRadians(),</span><br><span class="line">                endAngle: <span class="type">CGFloat</span>(<span class="number">0.0</span>).toRadians(),</span><br><span class="line">                clockwise: <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br><span class="line">path.addLine(to: <span class="type">CGPoint</span>(x: (width+startX) / <span class="number">2</span> + <span class="type">PieceConfigure</span>.holeRadius, y: startY))</span><br><span class="line">path.addLine(to: <span class="type">CGPoint</span>(x: width, y: startY))</span><br></pre></td></tr></table></figure><h3 id="封装一下"><a href="#封装一下" class="headerlink" title="封装一下"></a>封装一下</h3><p>OK，让我们整理一下，新建一个struct，命名为PieceSlicer，我们可以把切片的过程封装一下</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 拼图切片机</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PieceSlicer</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">PathDrawType</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> line</span><br><span class="line">        <span class="keyword">case</span> outside</span><br><span class="line">        <span class="keyword">case</span> inner</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Direction</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">left</span></span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">right</span></span><br><span class="line">        <span class="keyword">case</span> top</span><br><span class="line">        <span class="keyword">case</span> bottom</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> leftDraw: <span class="type">PathDrawType</span> = .line</span><br><span class="line">    <span class="keyword">var</span> topDraw: <span class="type">PathDrawType</span> = .line</span><br><span class="line">    <span class="keyword">var</span> rightDraw: <span class="type">PathDrawType</span> = .line</span><br><span class="line">    <span class="keyword">var</span> bottomDraw: <span class="type">PathDrawType</span> = .line</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> holeRadius: <span class="type">CGFloat</span> = <span class="number">6.0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(<span class="keyword">left</span>: <span class="type">PathDrawType</span>, top: <span class="type">PathDrawType</span>, <span class="keyword">right</span>: <span class="type">PathDrawType</span>, bottom: <span class="type">PathDrawType</span>) &#123;</span><br><span class="line">        leftDraw = <span class="keyword">left</span></span><br><span class="line">        topDraw = top</span><br><span class="line">        rightDraw = <span class="keyword">right</span></span><br><span class="line">        bottomDraw = bottom</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">draw</span><span class="params">(<span class="keyword">in</span> rect: CGRect)</span></span> -&gt; <span class="type">UIBezierPath?</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> startX = rect.origin.x</span><br><span class="line">        <span class="keyword">let</span> startY = rect.origin.y</span><br><span class="line">        <span class="keyword">let</span> width = rect.size.width</span><br><span class="line">        <span class="keyword">let</span> height = rect.size.height</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> path = <span class="type">UIBezierPath</span>()</span><br><span class="line">        path.move(to: <span class="type">CGPoint</span>(x: startX, y: startY))</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 因为绘图区域上下颠倒，这里我们直接把上和下的配置交换赋值</span></span><br><span class="line">        <span class="comment">// top</span></span><br><span class="line">        path.addLine(to: <span class="type">CGPoint</span>(x: (width + startX) / <span class="number">2</span>  - holeRadius, y: startY))</span><br><span class="line">        <span class="keyword">if</span> bottomDraw == .outside &#123;</span><br><span class="line">            path.addArc(withCenter: <span class="type">CGPoint</span>(x: (width+startX) / <span class="number">2</span>, y: startY - holeRadius),</span><br><span class="line">                        radius: holeRadius,</span><br><span class="line">                        startAngle: <span class="type">CGFloat</span>(<span class="number">180.0</span>).toRadians(),</span><br><span class="line">                        endAngle: <span class="type">CGFloat</span>(<span class="number">0.0</span>).toRadians(),</span><br><span class="line">                        clockwise: <span class="literal">true</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> bottomDraw == .inner &#123;</span><br><span class="line">            path.addArc(withCenter: <span class="type">CGPoint</span>(x: (width+startX) / <span class="number">2</span>, y: startY + holeRadius),</span><br><span class="line">                        radius: holeRadius,</span><br><span class="line">                        startAngle: <span class="type">CGFloat</span>(<span class="number">180.0</span>).toRadians(),</span><br><span class="line">                        endAngle: <span class="type">CGFloat</span>(<span class="number">0.0</span>).toRadians(),</span><br><span class="line">                        clockwise: <span class="literal">false</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        path.addLine(to: <span class="type">CGPoint</span>(x: (width+startX) / <span class="number">2</span> + holeRadius, y: startY))</span><br><span class="line">        path.addLine(to: <span class="type">CGPoint</span>(x: width, y: startY))</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// right</span></span><br><span class="line">        path.addLine(to: <span class="type">CGPoint</span>(x: width, y: height / <span class="number">2</span>))</span><br><span class="line">        <span class="keyword">if</span> rightDraw == .outside &#123;</span><br><span class="line">            path.addArc(withCenter: <span class="type">CGPoint</span>(x: width + holeRadius, y: height / <span class="number">2</span> + holeRadius),</span><br><span class="line">                        radius: holeRadius,</span><br><span class="line">                        startAngle: <span class="type">CGFloat</span>(<span class="number">270.0</span>).toRadians(),</span><br><span class="line">                        endAngle: <span class="type">CGFloat</span>(<span class="number">90.0</span>).toRadians(),</span><br><span class="line">                        clockwise: <span class="literal">true</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> rightDraw == .inner &#123;</span><br><span class="line">            path.addArc(withCenter: <span class="type">CGPoint</span>(x: width - holeRadius, y: height / <span class="number">2</span> + holeRadius),</span><br><span class="line">                        radius: holeRadius,</span><br><span class="line">                        startAngle: <span class="type">CGFloat</span>(<span class="number">270.0</span>).toRadians(),</span><br><span class="line">                        endAngle: <span class="type">CGFloat</span>(<span class="number">90.0</span>).toRadians(),</span><br><span class="line">                        clockwise: <span class="literal">false</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        path.addLine(to: <span class="type">CGPoint</span>(x: width, y: height / <span class="number">2</span> + holeRadius * <span class="number">2</span>))</span><br><span class="line">        path.addLine(to: <span class="type">CGPoint</span>(x: width, y: height))</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// bottom</span></span><br><span class="line">        path.addLine(to: <span class="type">CGPoint</span>(x: (width+startX) / <span class="number">2</span> + holeRadius, y: height))</span><br><span class="line">        <span class="keyword">if</span> topDraw == .outside &#123;</span><br><span class="line">            path.addArc(withCenter: <span class="type">CGPoint</span>(x: (width+startX) / <span class="number">2</span>, y: height + holeRadius),</span><br><span class="line">                        radius: holeRadius,</span><br><span class="line">                        startAngle: <span class="type">CGFloat</span>(<span class="number">0.0</span>).toRadians(),</span><br><span class="line">                        endAngle: <span class="type">CGFloat</span>(<span class="number">180.0</span>).toRadians(),</span><br><span class="line">                        clockwise: <span class="literal">true</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> topDraw == .inner &#123;</span><br><span class="line">            path.addArc(withCenter: <span class="type">CGPoint</span>(x: (width+startX) / <span class="number">2</span>, y: height - holeRadius),</span><br><span class="line">                        radius: holeRadius,</span><br><span class="line">                        startAngle: <span class="type">CGFloat</span>(<span class="number">0.0</span>).toRadians(),</span><br><span class="line">                        endAngle: <span class="type">CGFloat</span>(<span class="number">180.0</span>).toRadians(),</span><br><span class="line">                        clockwise: <span class="literal">false</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        path.addLine(to: <span class="type">CGPoint</span>(x: (width+startX) / <span class="number">2.0</span> - holeRadius, y: height))</span><br><span class="line">        path.addLine(to: <span class="type">CGPoint</span>(x: startX, y: height))</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// left</span></span><br><span class="line">        path.addLine(to: <span class="type">CGPoint</span>(x: startX, y: height / <span class="number">2</span> + startY))</span><br><span class="line">        <span class="keyword">if</span> leftDraw == .outside &#123;</span><br><span class="line">            path.addArc(withCenter: <span class="type">CGPoint</span>(x: startX - holeRadius, y: height / <span class="number">2</span> + holeRadius),</span><br><span class="line">                        radius: holeRadius,</span><br><span class="line">                        startAngle: <span class="type">CGFloat</span>(<span class="number">90.0</span>).toRadians(),</span><br><span class="line">                        endAngle: <span class="type">CGFloat</span>(<span class="number">270.0</span>).toRadians(),</span><br><span class="line">                        clockwise: <span class="literal">true</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> leftDraw == .inner &#123;</span><br><span class="line">            path.addArc(withCenter: <span class="type">CGPoint</span>(x: startX + holeRadius, y: height / <span class="number">2</span> + holeRadius),</span><br><span class="line">                        radius: holeRadius,</span><br><span class="line">                        startAngle: <span class="type">CGFloat</span>(<span class="number">90.0</span>).toRadians(),</span><br><span class="line">                        endAngle: <span class="type">CGFloat</span>(<span class="number">270.0</span>).toRadians(),</span><br><span class="line">                        clockwise: <span class="literal">false</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        path.addLine(to: <span class="type">CGPoint</span>(x: startX, y: height / <span class="number">2</span>))</span><br><span class="line">        <span class="comment">// done</span></span><br><span class="line">        path.close()</span><br><span class="line">        path.usesEvenOddFillRule = <span class="literal">true</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> path</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过简单的封装，我们已经完成了拼图切片状态的绘制代码，PathDrawType和Direction分别对应我们前文提到的切面类型和四个边，并且也是一一对应的。我们可以试一下：</p><p>现在构造一个简单的2x2的拼图，我们需要描述4个碎片的结构</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">PieceSlicer</span>(<span class="keyword">left</span>: .line, top: .line, <span class="keyword">right</span>: .outside, bottom: .inner),</span><br><span class="line"><span class="type">PieceSlicer</span>(<span class="keyword">left</span>: .inner, top: .line, <span class="keyword">right</span>: .line, bottom: .outside),</span><br><span class="line"><span class="type">PieceSlicer</span>(<span class="keyword">left</span>: .line, top: .outside, <span class="keyword">right</span>: .inner, bottom: .line),</span><br><span class="line"><span class="type">PieceSlicer</span>(<span class="keyword">left</span>: .outside, top: .inner, <span class="keyword">right</span>: .line, bottom: .line),</span><br></pre></td></tr></table></figure><p>运行效果如下：</p><p><img src="https://i.loli.net/2021/03/22/n2govAhsTMw6c9e.png" alt="piece-slice.png"></p><p>喔，有点像模像样了。就这样，我们的拼图切割已经初具雏形了。不过这样还很不灵活，接下来我们再看下，如何更自动和动态地生成拼图碎片。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第一篇-分析碎片切图&quot;&gt;&lt;a href=&quot;#第一篇-分析碎片切图&quot; class=&quot;headerlink&quot; title=&quot;第一篇 分析碎片切图&quot;&gt;&lt;/a&gt;第一篇 分析碎片切图&lt;/h2&gt;&lt;p&gt;拼图是一个老少咸宜的益智游戏，相信大家都玩过。有一天我突然看到街上的自定义照</summary>
      
    
    
    
    <category term="iOS" scheme="http://kinoandworld.github.io/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>《信条》与《时空幻境》的默契</title>
    <link href="http://kinoandworld.github.io/2020/09/22/Tenet-Braid/"/>
    <id>http://kinoandworld.github.io/2020/09/22/Tenet-Braid/</id>
    <published>2020-09-22T04:28:09.000Z</published>
    <updated>2025-10-28T09:01:11.518Z</updated>
    
    <content type="html"><![CDATA[<p>近期看完比较火的电影《信条》，且不论口碑如何，但绝对是很有实验性和艺术性的电影。<br>当然我的小脑袋一开始也没有很明白，然后随着我上网去看别人的解析，突然间我想起了多年前我玩过的一款游戏，二者对时间倒流的理解和艺术表达在我看来都非常相像。</p><p>这款游戏的名字叫《时空幻境》（《Braid》），是08年的一款独立游戏（虽然当年并不知道什么是独立游戏）。</p><h2 id="时空幻境"><a href="#时空幻境" class="headerlink" title="时空幻境"></a>时空幻境</h2><p>时空幻境是我最喜欢的独立游戏，没有之一。<br>其玩法的独创性、思想性和艺术性都让我叹为观止。</p><p>突然得知2021年会推出重制版！期待(*❦ω❦)</p><iframe src="//player.bilibili.com/player.html?aid=926641268&bvid=BV1oT4y1j7o2&cid=221589098&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><p><em>如果你看过《信条》，我相信你看到游戏的预告视频一定有浓烈的既视感</em></p><h3 id="时间的把戏"><a href="#时间的把戏" class="headerlink" title="时间的把戏"></a>时间的把戏</h3><p>故事的开始，起源于一段在城堡中，公主被邪恶的骑士掳走，主角没有追上，痛苦万分，最终踏上了拯救公主的道路——这与《超级玛丽》的故事听起来似乎如出一辙，甚至连玩法和画面都非常相似。</p><p><img src="https://media.st.dl.pinyuncloud.com/steam/apps/26800/0000007901.1920x1080.jpg" alt="img"></p><p>一开始我也是像超级玛丽一样玩，直到我被怪物碰到，人物挂在地上，却没有任何反应，直到系统提示我按下Shift键，然后画面中的一切回溯，眼睁睁地看着主角“起死回生”。<br> “这TM还能这样？！” —— 十年前玩的时候，就这样在了我幼小的心灵打开了新世界的小门。</p><p><img src="https://i.loli.net/2020/09/22/uXvYtihse6oTljm.gif" alt="起死回生"></p><p>游戏是由世界二开始的，最后的关卡是世界一，这其实就已经给了一个很大的暗示：最后一关才是最开始。<br>每一关的解谜都非常的精妙，画面和音乐也随着关卡的进行逐渐变化，越来越压抑与黑暗。<br>过程与体验不做过多介绍，着重说一下游戏的最后一关 —— 【世界一，谜题】。<br>在这一关中，公主被关在上层堡垒内，配合主角在下层一路披荆斩棘，越过层层机关后，终于走到尽头，看到公主在床上沉沉睡去。<br>可是主角来到公主身边，却什么也没有发生。<br>随着玩家习惯性地按下”时光倒流”按钮，令人瞠目结舌的一幕发生了。原来这你以为的终点才是一切的起点，随着画面倒转，原来是主角一直在追赶者公主，公主惊慌地逃跑，并且一路按下机关阻挠，最后被正义的骑士救走…</p><p>这个游戏打破了我对一个游戏【GAMEOVER-读档-重来】的固有认知，变成了【GAMEOVER-倒带-重来】，从一个离散过程转为连续过程，你甚至知道你究竟是哪一秒做错了才导致了失败。时隔多年，同样打破了我对一个时空电影的固有认知，这就是诺兰的新作《信条》，显然，是用同样的手法。</p><p>而我也稍微总结了下，二者的相似之处</p><h2 id="如出一辙"><a href="#如出一辙" class="headerlink" title="如出一辙"></a>如出一辙</h2><ul><li>名字（TENET &amp; braid）</li></ul><p>首先是名字的trick，大家都玩了一下文字游戏：<br>信条的石碑<br><img src="http://p6.itc.cn/q_70/images03/20200907/65e6026c87814d668f1d370dda0253f5.jpeg" alt="img"></p><p>braid的回文结构<br><img src="http://p7.itc.cn/q_70/images03/20200907/69cdd981a6fc4bfe9a1c718467e171fa.jpeg" width="50%" height="50%"></p><ul><li>音乐倒放</li></ul><p>在《信条》中，公路追逐战和巨轮渡洋都有很明显的音乐倒放，也算是诺兰给观众的温馨提示吧，或许只要是逆向过程，都是使用倒放BGM？我不太确定。<br>而在游戏中就相当直球了，回溯时间与BGM是同步的，你可以反复尝试。</p><ul><li>九块拼图</li></ul><p>《信条》中毁灭武器是由9块算法组件构成（对应着世界上9个拥有核武器的国家），而braid中每个世界都有一副主题画，一共6副（串联游戏的设计部分与叙事部分，相对比较晦涩）。</p><ul><li>核武器隐喻</li></ul><p>《时空幻境》中当你搜集完所有拼图之后，完成游戏最终关卡之后，你会发现整个游戏其实是一个巨大的隐喻，Tim象征着奥本海默、公主象征着原子弹。Tim的巨大后悔正是来自于“始终抗拒”的公主，他不该强迫公主——不该发明原子弹。<br><img src="http://p8.itc.cn/q_70/images03/20200907/75dc347a8bb24652ad76e54b94de0e82.jpeg" alt="游戏截图"></p><p>这句话是源于二战期间，美国的核试验成功了，责任人奥本海默说：“成功了。”<br>他的同事班布里奇说：“我们都成了混蛋。”（Now we are all sons of bitches.）</p><p>无独有偶，《信条》中也是直接引述了奥本海默说的这句“这一刻，我变成了死神，成为世界万物的毁灭者”。<br>顺带一提，这句话出自印度史诗《摩诃婆罗多》，不止于此，当原爆乍起，奥本海默说他想到了《摩诃婆罗多》中的《福者之歌》：「漫天奇光异彩，犹如圣灵逞威，祇有千只太阳，始能与它争辉」。</p><p>无论是核武器还是逆熵装置，人类始终有无法掌控的潘多拉魔盒，人类最大的敌人真的很可能就是人类本身。</p><ul><li>因果链倒置</li></ul><p>就像上文对游戏的介绍一样，仅仅是对时间这单一参数的倒置，就能让故事变得面目全非，主人公Tim由被害者变成加害者，骑士由绑匪变成拯救者。对时间的操作本质是对因果的解构和调整，所以针对时间穿越的逻辑悖论（如祖父悖论）大多也都是因为逻辑问题。《信条》之所以这么难懂，就是因为他将多个表象与实际的因果顺序互相调换，如果你没有拆分出详细的因果链，就会对电影里看到的一切感到迷茫。从这一点上来说，《信条》玩得更深，也更狠。</p><hr><p>我相信我列出的二者的相似点只是冰山一角，当然，我并不知道诺兰是否知道这款游戏，这更有可能是一个英雄所见略同的结果，而且《信条》中熵概念的引入和人物因为时间倒置的情感设计也是非常精妙的，再说了，我觉得好的东西就应该互相借鉴嘛哈哈哈哈哈哈哈（拍</p><h2 id="其名为熵"><a href="#其名为熵" class="headerlink" title="其名为熵"></a>其名为熵</h2><blockquote><p>生命以负熵为食 ——薛定谔</p></blockquote><p>最后我想说一下熵，著名的热力学第二定律，也就是熵增定理如是说：</p><p><code>一个孤立的系统的熵总是自发地增加。</code></p><p>能量的使用和转移也必然伴随着更大系统的熵增，能量的转换效率也无法做到100%。<br>这也从理论上决定了第二类永动机是无法实现的。</p><p>熵增定理的普适性远不止于此，小到微观世界粒子的无序运动，大到整个宇宙的燃烧和演化，现在更是扩展到了信息学和管理学之中，极端一点来说，你可以用熵增定理来解释宇宙从大爆炸开始到今天发生的一切。</p><p>前几天还看到一种说法，说时间并不存在，只是人类用来度量变化的假想工具，世界的进行和演变只是因果互相影响的过程。这个说法是否正确我不知道，但是这样印证了时间操纵本质上是因果操纵这种想法。</p><p>当然，电影中还有许多值得揣摩或者不合理的部分，或许它的观影体验并不是对所有人都很好，但是我认为能引发一些思考，还是很有意义的。</p><hr><p>引用&amp;参考：</p><p><a href="https://www.sohu.com/a/416931064_116000">看不懂《信条》？也许你该玩玩《时空幻境》 </a></p><p><a href="https://cowlevel.net/article/1888385">时空幻境回忆杀，七年前整理（剧情分析向）</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;近期看完比较火的电影《信条》，且不论口碑如何，但绝对是很有实验性和艺术性的电影。&lt;br&gt;当然我的小脑袋一开始也没有很明白，然后随着我上网去看别人的解析，突然间我想起了多年前我玩过的一款游戏，二者对时间倒流的理解和艺术表达在我看来都非常相像。&lt;/p&gt;
&lt;p&gt;这款游戏的名字叫《</summary>
      
    
    
    
    <category term="林中笔记" scheme="http://kinoandworld.github.io/categories/%E6%9E%97%E4%B8%AD%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://kinoandworld.github.io/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>荣誉与胜利哪个更重要 —— 玩《对马岛之鬼》有感</title>
    <link href="http://kinoandworld.github.io/2020/08/20/Ghost-of-Tsushima/"/>
    <id>http://kinoandworld.github.io/2020/08/20/Ghost-of-Tsushima/</id>
    <published>2020-08-20T10:25:07.000Z</published>
    <updated>2025-10-28T09:01:11.518Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>我以我血荐对马，雪恨不惜化恶鬼</p></blockquote><p><img src="https://i.loli.net/2020/08/19/aJB9hn1tNuEjyQ2.jpg" alt="Ghost of Tsushima_20200805230954_1.jpg"></p><p>说起《对马岛之鬼》，我第一次看到这个游戏的宣传片还是在2017年，在那个只狼还未见踪迹的时候，看到这样一个在凄厉月色下，刀光剑影间斩杀敌人的武士游戏，它满足了我对冷兵器时代武士间战斗的幻想，太酷了。</p><p>时隔三年，直到2019年年度大作《只狼》出世并让世界玩家沸腾后的今年，也许不会有这么多玩家还对这部作品翘首以盼。更何况因为今年某部大作的暴雷，让大家对这部作品都保持了观望的态度。当然我还是第一时间入手了，虽然有点忐忑，但对马岛并没有让我失望，一开始的剧情就很抓人，而后渐入佳境，沉迷了好一段时间（时间管理失败者）😆。销量也是在口碑回潮后节节高升，算是今年主机游戏的一匹黑马~</p><h3 id="一块璞玉"><a href="#一块璞玉" class="headerlink" title="一块璞玉"></a>一块璞玉</h3><p>对马给我的重要吸引力之一就是精致唯美的画面，就结果而言，也确实无愧于”每一帧都是壁纸“这个称号，无论是<br>随风摆动的芦苇地、漫天飞舞的红叶，甚至是主人公踏马前行的衣袂翻飞，都无疑是一幅幅美丽的风景画。<br>再加上各种场景散落的甚至是有些夸张的粒子效果<br>这也无怪乎这个游戏的”摄影爱好者“如此众多了。</p><p><img src="https://i.loli.net/2020/08/19/p7356iBfoZMscQz.jpg" alt="Ghost of Tsushima_20200721215823_1.jpg"></p><p><img src="https://i.loli.net/2020/08/19/CIpyPbLXZH7r8ew.jpg" alt="Ghost of Tsushima_20200809140159_1.jpg"></p><p><img src="https://i.loli.net/2020/08/19/9qpJnTDM1eP6rs4.jpg" alt="图片细节在放大后都相当丰富"><br><em>图片细节在放大后都相当丰富</em></p><p>除去画面之外，游戏的动作元素也是无可挑剔，无论是以一敌多的华丽连击，还是单挑对决中的见招拆招，”卑鄙“的手段也不少，各种炸弹暗器、飞箭毒针，你可以玩成真三国无双，也可以玩成刺客信条。相对于道具系统，装备系统的种类不多，但功能性也足够别出心裁，而且某些皮肤真的超帅。</p><p><img src="https://i.loli.net/2020/08/19/ilEfLqozY3C5HIg.jpg" alt="Ghost of Tsushima_20200806222718.jpg"></p><p>值得一提的是，对马岛的几个重要人物支线都非常精彩，而且他们并不能一口气做完，而是与主线交织前进的，我甚至认为它们就是主线的一部分。不仅是主角在成长，这些主角的伙伴们也不断在成长，他们跟主角一样都是这场浩劫的受害者，但他们也有各自的人生。而后在对蒙古军队发动总攻的时候，这些支线的人物也汇聚在一起，这是真正意义上的百川归海。</p><h3 id="Other-Side"><a href="#Other-Side" class="headerlink" title="Other Side"></a>Other Side</h3><p>游戏的音乐与音效也是美的恰到好处，无论是与风景的配合，还是与剧情的搭配，都很大程度上让玩家更有代入感，更有“江湖气”。另外，游戏不管是对日本建筑的刻画还是对蒙古军营的刻画都非常细致和生动，甚至是日月星辰和一草一木都具有十足的东方气息，我一度忘记这个游戏是欧美做的，这真的是反向文化输出了…</p><p>另外值得一提是俳句，我的第一反应就是这个跟中国古诗好像…</p><p><img src="https://i.loli.net/2020/08/19/zhqxvpY5cjUw84X.jpg" alt="俳句的创作很有意思"><br><em>俳句的创作玩法很有意思，也希望有一天能在游戏中能看到唐诗宋词</em></p><blockquote><p>俳句的原型是中国古代汉诗中的绝句。日本中古的时候将中国汉诗的乐府诗发展为和歌。</p></blockquote><p>当然，这部作品并非完美无瑕，在我看来，最严重的的问题仍然是”太过公式化“。地图中规律的遍布着狐狸巢、神社、灯塔，野外遭遇战也几乎有个姿势一模一样的农民呼叫救援，虽然也不能说不合理，但是过于规律会给人以”人造“而不是”自然“的感觉。当然，作为一个开放世界游戏，某种程度上”公式化”也是最经济合理而且易于被玩家理解的方式，这一点在几乎所有开放世界游戏中都有所瞥见。另外，对比另一款作品《只狼》来说，对马岛的BOSS实在有些拉胯，招式单一而且不够特别，气氛的渲染和地图限制也比较平平无奇。</p><h3 id="武士与战鬼"><a href="#武士与战鬼" class="headerlink" title="武士与战鬼"></a>武士与战鬼</h3><p><img src="https://i.loli.net/2020/08/19/6POlXNRc5Szmigj.jpg"></p><p>《对马》中最令我回味的，还是主人公由武士到战鬼的转变历程。<br>井镜仁由武士变成了刺客、忍者、杀手、甚至鬼魅，唯独不在是武士，因为武士的核心的荣誉，是光明正大，是用正义的手段行正义之事的正义的伙伴。但这却是主人公得以拯救民众的必要蜕变，游戏初期的惨败和绝地求生，让仁明白有时候在生存面前，荣誉和尊严是不值得一提的。（我潜心盗窃心狠手辣 但我是个好男孩.jpg）</p><p>这与毫不动摇地信守武士精神的志村舅舅在几乎一开始，就埋下了冲突的种子。</p><p>光明磊落的胜利与作最小牺牲的胜利变成了鱼与熊掌的两难困境，两个人也不得不因此走向对立面。</p><p>一开始我认为，志村舅舅的所谓武士荣誉只是迂腐的封建家长式的执拗，但是当我看到他面对仁的痛苦和艰难的决裂下，宁愿身死也要维护的信念，虽然略显天真，但也绝对值得尊敬。</p><p>两人的矛盾在顺利击败蒙古人之后达到了顶峰，在这片秋风染红的满地萧瑟中，本该是携手共渡的一双手，却举起了指向对方的剑。</p><p><img src="https://i.loli.net/2020/08/19/R27OTXEpFjNDzbi.jpg" alt="Ghost of Tsushima_20200809021830.jpg"></p><p><img src="https://i.loli.net/2020/08/19/YirevKZGVSqQ82a.jpg" alt="Ghost of Tsushima_20200809022226_1.jpg"></p><p>年事已高的舅舅又岂是百战中绝地求生的战鬼的对手<br>只几个回合，高下立判。<br>游戏的最后，面对亦师亦父的舅舅求死的请求，选择权交由给玩家。</p><p>我选择了拒绝杀死舅舅，这不仅是对舅舅活下去的希望，也是对武士精神最彻底的背离。你们都叫我战鬼，那我就当鬼，我也会以我的方式继续活下去。战火蔓延下的对马，不管是人还是鬼都不能幸免，但在时间的长河中，一切也将湮灭在日月交替之后，天地不仁。</p><p><img src="https://i.loli.net/2020/08/19/GLBfig1IsbxCZv9.jpg" alt="Ghost of Tsushima_20200809014642.jpg"></p><p>PS：</p><p>不是说好了马是不会死的吗<br><img src="https://i.loli.net/2020/08/19/Tt3aLJHBsSeCzvW.jpg" alt="Ghost of Tsushima_20200807212819_1.jpg"></p><p>真正的武士是不需要衣服哒<br><img src="https://i.loli.net/2020/08/19/3EVgLiKB2pM9vNw.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;我以我血荐对马，雪恨不惜化恶鬼&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/08/19/aJB9hn1tNuEjyQ2.jpg&quot; alt=&quot;Ghost of Tsushima_202</summary>
      
    
    
    
    <category term="林中笔记" scheme="http://kinoandworld.github.io/categories/%E6%9E%97%E4%B8%AD%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="游戏" scheme="http://kinoandworld.github.io/tags/%E6%B8%B8%E6%88%8F/"/>
    
  </entry>
  
  <entry>
    <title>我眼中的蒸汽朋克</title>
    <link href="http://kinoandworld.github.io/2019/05/11/%E6%88%91%E7%9C%BC%E4%B8%AD%E7%9A%84%E8%92%B8%E6%B1%BD%E6%9C%8B%E5%85%8B/"/>
    <id>http://kinoandworld.github.io/2019/05/11/%E6%88%91%E7%9C%BC%E4%B8%AD%E7%9A%84%E8%92%B8%E6%B1%BD%E6%9C%8B%E5%85%8B/</id>
    <published>2019-05-11T04:53:01.000Z</published>
    <updated>2025-10-28T09:01:11.519Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>蒸汽朋克这个名词最早是在1987年的《轨迹》杂志中提出，但是蒸汽朋克的概念和作品涉及却最早可以追溯到儒勒·凡尔纳的《海底两万里》、威廉·吉布森的《差分机》还有乔治·梅里爱的《月球旅行记》等，在各个领域都有所涉猎。</p><p>其实这应该也是受到当时科幻”黄金时代“的大环境影响所致。同时出现的，还有赛博朋克和各种变种，诸如柴油朋克、生化朋克、晶体管朋克等等，可谓百家争鸣，文体多开花。</p></blockquote><p>随着瓦特蒸汽机的全面运用和发展，第一次工业革命后的英国维多利亚时代处于时代的巅峰。由此带来的人们对机械和崇拜和追求，同时引领着人们的审美和潮流。那是一个崇尚奢华、优雅与浪漫的年代，认识到科技的巨大颠覆力的人们开始各种各样异想天开的发明创造。蒸汽朋克正是以这样一个时代背景作为基底，融合了浪漫主义内核，构筑了一个自上而下都是由机械和齿轮构筑的科幻世界。</p><hr><h3 id="艺术风格"><a href="#艺术风格" class="headerlink" title="艺术风格"></a>艺术风格</h3><p><em>蒸汽朋克下的钢铁都市</em></p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/yKRcicl06QMWGHHPlIWnMLn4FMoyx76qn5aWiaCA5BLicTn2f3oWKkiaWiaYwNjy1qaSOk6sSPiaOJBO5sAdh0TUgsdg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="蒸汽朋克下的钢铁都市"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/yKRcicl06QMWGHHPlIWnMLn4FMoyx76qnRKb3rW2caBhVt71DiajUSUKNVjRdT1Gb3OePAiaMENnmic3ZVIibH77rtw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="带着一点点中世纪的余韵却有高度发达的城市系统。巨大的机械，震耳欲聋的轰鸣和席卷苍穹的蒸汽让人们征服自然的强烈成就感油然而生。"></p><p><em>大到横贯天空的庞然大物</em></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/yKRcicl06QMWGHHPlIWnMLn4FMoyx76qnbaLpCicPicoc228PuwVOO2jGWRwdWA8qVQwicKotVSq8FIy1qV9A6tV6g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="巨型飞艇是蒸汽朋克的经典产物（看着超酷虽然可能速度不怎么快"></p><p><em>小到可以躺在指尖的小玩意儿</em></p><p> <img src="https://mmbiz.qpic.cn/mmbiz_jpg/yKRcicl06QMVITnbJAAtSW0eATDz1uSmsBcCZnDEAQZBdT2djqx2ZpTFhfg8IrY6chZmGp3EHvHQgnxhsKTOQfQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">  <img src="https://mmbiz.qpic.cn/mmbiz_png/yKRcicl06QMWGHHPlIWnMLn4FMoyx76qnlQXbib4t3uWm4jBicr9NqzUtx87RFYZQxzcTm5Yym8VBBEFVRsQzI6yg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1"> </p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/yKRcicl06QMVY30mvOZkzdCOFLUMhzvrh5F17ibM1yHtP8UhY2rDVI1cFzWZ9lOnicjiaWEA37xaPbApnRVR33Vtwg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="《紫罗兰永恒花园》中的打字机"></p><p>从虚拟艺术创作到显示工业制造，蒸汽朋克的美都是饱受推崇且独树一帜的。</p><hr><p>可以说，赛博朋克是将第一次工业革命成果发挥到极致的产物，而最让人倾心的是它将工业与美学的完美结合，结构外露却又细腻精致，充满力量又规律整齐。除此之外，蒸汽朋克有着很显著的服饰和建筑风格。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/yKRcicl06QMVITnbJAAtSW0eATDz1uSmsmH3x7bFzYxE8dPM0LXD9iauIxmRV23qe6ueY4jwro8I5k0rDXu5bQNg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="维多利亚风格"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/yKRcicl06QMWGHHPlIWnMLn4FMoyx76qn1QXJb1yzAAN9KmmBTOOO15lXcz80WRP4barpUJI45ORTxRwGfiaSMsg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="尼尔小姐姐的服装也是非常为多路特色→→"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/yKRcicl06QMWGHHPlIWnMLn4FMoyx76qnNoVPynRHeTSn0qEiaoiaIzYYEN5ooadK1hPibgs0DyygOahibhIkaIJxCA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="偏哥特式建筑"></p><p>维多利亚风格的基本特点就是，奢华、典雅、<del>不实用</del></p><p>但是好看啊，好看就是正义<img src="https://res.wx.qq.com/mpres/htmledition/images/icon/common/emotion_panel/emoji_ios/u1F637.png?tp=webp&wxfrom=5&wx_lazy=1&wx_co=1"></p><h3 id="剑与魔法"><a href="#剑与魔法" class="headerlink" title="剑与魔法"></a><strong>剑与魔法</strong></h3><p>严格来说，蒸汽动力是一种很低效的能源，所以为了让蒸汽朋克的世界更加精彩和有趣，各类作品一般会引入各种更高效的能源作为动力补充。</p><ul><li>譬如《最终幻想7》中的 “魔晄”</li><li>譬如《空之轨迹》中的”导力”</li><li>譬如《耻辱》中的”鲸油”</li><li>譬如《尸者帝国》中的”尸件”（这个比较诡异233）</li></ul><p>其中最喜闻乐见的，就是魔法元素了</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/yKRcicl06QMVY30mvOZkzdCOFLUMhzvrh6vOSk0icicHQH67WwicYFqEpcOVC1dY5dV2icrT0x1N4ibNqCnuoCtzuoRQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="《哈儿的移动城堡中》蒸汽朋克 mix 魔法元素"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/yKRcicl06QMVY30mvOZkzdCOFLUMhzvrhRjDNibWcsQY326zoOG3l0l0bYP81Wl8dpqMWNzM9hPldArYpTjuL9eQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1"></p><p>说起来，我的蒸汽朋克启蒙作品，是一款名不见经传，运营仅仅两年就关服的网游《蒸汽幻想》。在当年还不知道蒸汽朋克为何物的我，在机缘巧合下打开这款游戏，立刻被其中各式各样的机械元素和广袤大陆所吸引，各式种族的自由选择，剑与魔法和谐共处，令人神往。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/yKRcicl06QMVY30mvOZkzdCOFLUMhzvrhZsZMquyviayfbNZyGeVvUWibvUIR1pHiaaU58sgO7qRMJAga2kLRYWibWw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="一看就很有年代感的游戏"></p><p>此外，还有很多的电影和游戏作品都掺杂了蒸汽朋克元素</p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/yKRcicl06QMVITnbJAAtSW0eATDz1uSms2GY3JssKvibsjY2ibWmpmrlZhakVp3V7CCxFq5wL7VS17nVCPn3AuIRg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="机械迷城"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/yKRcicl06QMVITnbJAAtSW0eATDz1uSmsZPGha5LoKrTTeDna8UCoQBFsGLNXOSibdQfvWEO7gkVWm3Fo9Tr2zzw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="雨果的秘密"></p><h3 id="蒸汽与乌托邦"><a href="#蒸汽与乌托邦" class="headerlink" title="蒸汽与乌托邦"></a><strong>蒸汽与乌托邦</strong></h3><p>反观现代信息社会，电力和核能都太微观而且不可捉摸，就连核心基础的计算机也是基于二进制的，所有的一切都包在简陋的外壳之下，我们很难看清各种设备的本质，同时，我们很难看清社会的本质。了解得越多，越是觉得人类的渺小。我们期待科技可以让我们的生活变得更好，没想到反而将人与人割裂成一座座孤岛。更接近与现代社会的赛博朋克的内核是反乌托邦的，更多地来自于对现有社会的悲观投影。所以我会更加钟情于蒸汽朋克的世界</p><p>笨重而温暖。</p><p>也许，我真正怀念的，是那个缤纷繁杂，社会秩序整齐划一，人们积极乐观的乌托邦世界。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;蒸汽朋克这个名词最早是在1987年的《轨迹》杂志中提出，但是蒸汽朋克的概念和作品涉及却最早可以追溯到儒勒·凡尔纳的《海底两万里》、威廉·吉布森的《差分机》还有乔治·梅里爱的《月球旅行记》等，在各个领域都有所涉猎。&lt;/p&gt;
&lt;p&gt;其实这应该也是受到当</summary>
      
    
    
    
    <category term="林中笔记" scheme="http://kinoandworld.github.io/categories/%E6%9E%97%E4%B8%AD%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://kinoandworld.github.io/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>iOS中使用WKWebview支持h5跳转支付客户端</title>
    <link href="http://kinoandworld.github.io/2018/07/23/iOS%E4%B8%AD%E4%BD%BF%E7%94%A8WKWebview%E6%94%AF%E6%8C%81h5%E8%B7%B3%E8%BD%AC%E6%94%AF%E4%BB%98%E5%AE%A2%E6%88%B7%E7%AB%AF/"/>
    <id>http://kinoandworld.github.io/2018/07/23/iOS%E4%B8%AD%E4%BD%BF%E7%94%A8WKWebview%E6%94%AF%E6%8C%81h5%E8%B7%B3%E8%BD%AC%E6%94%AF%E4%BB%98%E5%AE%A2%E6%88%B7%E7%AB%AF/</id>
    <published>2018-07-23T10:24:08.000Z</published>
    <updated>2025-10-28T09:01:11.519Z</updated>
    
    <content type="html"><![CDATA[<p>大致的业务场景是这样的：我们的客户端APP本身不包含支付SDK，但是在APP内打开的HTML5是包含了第三方支付的，而且在Safari内是可以正常调起支付宝/微信客户端进行支付的，然而在APP的webview内打开同样的URL则毫无反应。<br>原因大致是支付宝/微信的h5支付sdk没有对客户端支持，当然也存在一些系统的限制。<br>现在就来解决一下这个问题。</p><h3 id="柳暗"><a href="#柳暗" class="headerlink" title="柳暗"></a>柳暗</h3><p>经过稍微的查询和参考，解决方案其实非常简单，只需要在<code>WKWebView</code>的代理方法<code>func webView(_ webView: WKWebView, decidePolicyFor navigationAction: WKNavigationAction, decisionHandler: @escaping (WKNavigationActionPolicy) -&gt; Void)</code>内监听微信/支付宝的特定前缀URL，然后使用<code>openUrl</code>方法打开这个URL就可以触发支付宝/微信的scheme。具体代码大致如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">webView</span><span class="params">(<span class="number">_</span> webView: WKWebView, decidePolicyFor navigationAction: WKNavigationAction, decisionHandler: @escaping <span class="params">(WKNavigationActionPolicy)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    pushCurrentSnapshotViewWithRequest(request: navigationAction.request)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> curUrl = navigationAction.request.url <span class="keyword">else</span> &#123;</span><br><span class="line">        decisionHandler(.allow); <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> curUrl.absoluteString.hasPrefix(<span class="string">&quot;alipay://alipayclient/&quot;</span>) || curUrl.absoluteString.hasPrefix(<span class="string">&quot;weixin://&quot;</span>)&#123;</span><br><span class="line">        decisionHandler(<span class="type">WKNavigationActionPolicy</span>.cancel)</span><br><span class="line">        <span class="type">UIApplication</span>.shared.openURL(url)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    decisionHandler(<span class="type">WKNavigationActionPolicy</span>.allow)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开心，居然这么简单。<br>然后…emmmmm，跳是可以正常跳了，但是好像支付结束后无法跳回APP。<br>冷静分析一下，我们都知道iOS内的应用间跳转，基本都是通过scheme的方式，跳出去如此，要返回也是如此。</p><h3 id="花明"><a href="#花明" class="headerlink" title="花明"></a>花明</h3><p>先看下支付宝支付：<br>捕获支付宝web支付跳转链接如 <code>alipay://alipayclient/?&#123;&quot;requestType&quot;:&quot;SafePay&quot;,&quot;fromAppUrlScheme&quot;:&quot;alipays&quot;,&quot;dataString&quot;:&quot;h5_route_token=\&quot;shierRZ25\&quot;&amp;is_h5_route=\&quot;true\&quot;&quot;&#125;</code><br>发现其中只要将fromAppUrlScheme改为APP内配置的scheme，即可正确跳转回应用。具体代码示例如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fileprivate</span> <span class="function"><span class="keyword">func</span> <span class="title">handleAlipayUrl</span><span class="params">(url: URL)</span></span> -&gt; <span class="type">URL?</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> url.absoluteString.hasPrefix(<span class="string">&quot;alipay://alipayclient/&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">// 更换scheme</span></span><br><span class="line">        <span class="keyword">var</span> decodePar = url.query ?? <span class="string">&quot;&quot;</span></span><br><span class="line">        decodePar.urlDecode()</span><br><span class="line">        <span class="keyword">var</span> dict = <span class="type">JSON</span>(parseJSON: decodePar)</span><br><span class="line">        dict[<span class="string">&quot;fromAppUrlScheme&quot;</span>] = <span class="string">&quot;xproject&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> strData = <span class="keyword">try</span>? <span class="type">JSONSerialization</span>.data(withJSONObject: dict.dictionaryObject ?? [:], options: []) &#123;</span><br><span class="line">            <span class="keyword">var</span> param = <span class="type">String</span>(data: strData, encoding: .utf8)</span><br><span class="line">            param?.urlEncode()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> finalStr = <span class="string">&quot;alipay://alipayclient/?\(param ?? &quot;</span><span class="string">&quot;)&quot;</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> finalUrl = <span class="type">URL</span>(string: finalStr) &#123;</span><br><span class="line">                <span class="keyword">return</span> finalUrl</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> url</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>似乎挺顺利，再看一下微信，微信的h5支付回调应该是服务端提供的一个h5地址，因此支付完成后默认是跳转到了Safari，在APP内进行的支付，我们要换掉这个回调，变成我们自己的。</p><p>大致步骤是：</p><ul><li>工程文件添加Scheme，内容为[APP本地配置的scheme]</li><li>捕获跳转链接 <a href="https://wx.tenpay.com/cgi-bin/mmpayweb-bin/checkmweb%EF%BC%8C%E5%B0%86%E5%85%B6%E4%B8%AD%E5%85%B6%E4%B8%AD%E7%9A%84redirect_url%E5%8F%82%E6%95%B0%E6%8D%A2%E6%88%90[APP%E6%9C%AC%E5%9C%B0%E9%85%8D%E7%BD%AE%E7%9A%84scheme]">https://wx.tenpay.com/cgi-bin/mmpayweb-bin/checkmweb，将其中其中的redirect_url参数换成[APP本地配置的scheme]</a></li><li>重新发起请求，给请求头加上Referer字段，内容为[APP本地配置的scheme]</li><li>使用openUrl发起微信客户端调用<br>这里参考了这篇文章 <a href="https://www.jianshu.com/p/c1973aacc774">https://www.jianshu.com/p/c1973aacc774</a><br>需要注意的一点就是，[APP本地配置的scheme]需要是http的URL形式，而且根域名是要包含在微信支付后台填写的白名单内的，譬如白名单域名是abc.com，你可以将你的scheme设置为ios.abc.com，否则也不会生效。</li></ul><p>具体代码大致如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> wxpayScheme = <span class="string">&quot;ios.abc.com://&quot;</span></span><br><span class="line"><span class="comment">// 去除原有的URL回调地址，换成自己的配置</span></span><br><span class="line"><span class="keyword">if</span> curUrl.absoluteString.hasPrefix(<span class="string">&quot;https://wx.tenpay.com/cgi-bin/mmpayweb-bin/checkmweb&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">var</span> comps = <span class="type">URLComponents</span>(string: curUrl.absoluteString) &#123;</span><br><span class="line">        <span class="keyword">var</span> needChange = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">for</span> (idx, item) <span class="keyword">in</span> (comps.queryItems ?? []).enumerated() &#123;</span><br><span class="line">            <span class="keyword">if</span> item.name == <span class="string">&quot;redirect_url&quot;</span> &amp;&amp; item.value != wxpayScheme &#123;</span><br><span class="line">                needChange = <span class="literal">true</span></span><br><span class="line">                comps.queryItems?.remove(at: idx)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> needChange &#123;</span><br><span class="line">            comps.queryItems?.append(<span class="type">URLQueryItem</span>(name: <span class="string">&quot;redirect_url&quot;</span>, value: wxpayScheme))</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> finalUrl = comps.url &#123;</span><br><span class="line">                <span class="comment">// 给请求头加上Referer字段</span></span><br><span class="line">                <span class="keyword">let</span> mRequest = <span class="type">NSMutableURLRequest</span>(url: finalUrl)</span><br><span class="line">                mRequest.setValue(wxpayScheme, forHTTPHeaderField: <span class="string">&quot;Referer&quot;</span>)</span><br><span class="line"></span><br><span class="line">                decisionHandler(<span class="type">WKNavigationActionPolicy</span>.cancel)</span><br><span class="line">                webView.load(mRequest <span class="keyword">as</span> <span class="type">URLRequest</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>替换的过程有一点绕，其实就是找到相应字段替换掉，有更好地写法。<br>尝试了一下，可以成功跳转回来了，但是新的问题又出现了→_→</p><h3 id="又一村"><a href="#又一村" class="headerlink" title="又一村"></a>又一村</h3><p>因为替换了微信支付的回调，h5的跳转可能会出现白屏的问题，上面的文章也有提到。<br>我根据自己的实际情况采用了直接强制调用<code>webView.goBack()</code>，因为本身的H5页面自带了支付等待完成页，支付完成后返回APP，确认一下支付状态就好了。<br>需要注意的是，调用微信支付5秒后，webview会收到一个链接调整，截获然后进行后退就好：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> curUrl.absoluteString.hasPrefix(wxpayScheme) &#123;</span><br><span class="line">    <span class="comment">// 进入空白页，强制后退</span></span><br><span class="line">    decisionHandler(<span class="type">WKNavigationActionPolicy</span>.cancel)</span><br><span class="line">    webView.goBack()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过这个白屏问题可能会根据本身h5的不同而采取不同的解决方案，所以这个应该并非万全之策。</p><p>参考文章：<br><a href="https://www.jianshu.com/p/90db7dfb075c">iOS 解决微信h5支付无法直接返回APP的问题</a><br><a href="https://www.jianshu.com/p/c1973aacc774">iOS微信H5支付无法返回APP解决方案</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;大致的业务场景是这样的：我们的客户端APP本身不包含支付SDK，但是在APP内打开的HTML5是包含了第三方支付的，而且在Safari内是可以正常调起支付宝/微信客户端进行支付的，然而在APP的webview内打开同样的URL则毫无反应。&lt;br&gt;原因大致是支付宝/微信的h5</summary>
      
    
    
    
    <category term="iOS" scheme="http://kinoandworld.github.io/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>Swift项目初体验琐记（2）</title>
    <link href="http://kinoandworld.github.io/2017/04/09/Swift%E9%A1%B9%E7%9B%AE%E5%88%9D%E4%BD%93%E9%AA%8C%E7%90%90%E8%AE%B0%EF%BC%882%EF%BC%89/"/>
    <id>http://kinoandworld.github.io/2017/04/09/Swift%E9%A1%B9%E7%9B%AE%E5%88%9D%E4%BD%93%E9%AA%8C%E7%90%90%E8%AE%B0%EF%BC%882%EF%BC%89/</id>
    <published>2017-04-08T16:04:35.000Z</published>
    <updated>2025-10-28T09:01:11.518Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Swift上的常用第三方框架"><a href="#Swift上的常用第三方框架" class="headerlink" title="Swift上的常用第三方框架"></a>Swift上的常用第三方框架</h3><ul><li><p>Alamofire<br>  相当于OC上的AFNetWorking，毕竟作者也是同一个人😂。不过在Swift上，一般还会搭配其他框架封装在一起。这个等会一起介绍。</p></li><li><p>RxSwift<br>  相对于ReactiveCocoa的swift版本来说，RxSwift似乎更“血统纯正”一些，就我个人的使用而言，与ReactiveCocoa的基本用法还是非常相似的。RxSwift的教程也很多，就不展开了。</p></li><li><p>SnapKit<br>对应Objective-C上的masorny，同一家写的，语法几乎一样~</p></li><li><p>Kingfisher<br>喵神写的，对应于SDWebImage 或者 YYWebImage</p></li><li><p>HandyJSON：<br>阿里巴巴团队开源的Json自动转model框架，现有的Json转model的第三方库基本都是用到了上篇文章提到的<code>Mirror</code>（反射）把model所有字段映射出来然后匹配，但是似乎都不能支持像Objective-C的一些库可以不用写映射自动用变量名匹配字段名。而HandyJson用了一个很高端的<code>内存位移映射</code>的办法来实现变量名匹配和赋值，可以让你不用重载任何mapping方法就能自动转成Model。（对原理感兴趣的可以戳<a href="http://www.jianshu.com/p/eac4a92b44ef">这里</a>）</p></li></ul><h3 id="Moya-RxSwift-HandyJSON"><a href="#Moya-RxSwift-HandyJSON" class="headerlink" title="Moya + RxSwift + HandyJSON"></a>Moya + RxSwift + HandyJSON</h3><p>在App中我们最常打交道的或许就是网络模块了，虽然Alomfire写得非常棒，但是我们在项目中一般不会直接使用，而是再通过一个网络层封装，得以对接我们的具体业务和配置，懒惰如我，四处搜寻一个好的网络层解决方案，然后发现<a href="https://github.com/Moya/Moya">Moya</a>这个第三方网络中间件，我将在本文着重介绍。</p><p>首先，他的基础用法和扩展<a href="https://blog.callmewhy.com/2015/11/01/moya-rxswift-argo-lets-go/">这篇文章</a>已经写得很清楚了，不过我们这里没有用argo，而是用了上面提到的HandyJSON</p><p>OK，还是用实例说话，首先我们新增一个可重用的extension</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ObservableType</span> <span class="title">where</span> <span class="title">E</span> == <span class="title">Moya</span>.<span class="title">Response</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">preOrderCheck</span><span class="params">(response: Response)</span></span> <span class="keyword">throws</span> -&gt; <span class="type">JSON</span> &#123;</span><br><span class="line">        <span class="comment">// check http status</span></span><br><span class="line">        <span class="keyword">guard</span> ((<span class="number">200</span>...<span class="number">209</span>) ~= response.statusCode) <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="type">ServiceError</span>.<span class="type">NotSuccessfulHTTP</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// unwrap biz json shell</span></span><br><span class="line">        <span class="keyword">let</span> json = <span class="type">JSON</span>.<span class="keyword">init</span>(data: response.data)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// check biz status</span></span><br><span class="line">        <span class="keyword">let</span> code = json[<span class="type">RESULT_CODE</span>].stringValue</span><br><span class="line">        <span class="keyword">if</span> code == <span class="type">BizStatus</span>.<span class="type">BizSuccess</span>.rawValue &#123;</span><br><span class="line">            <span class="keyword">return</span> json[<span class="type">RESULT_DATA</span>]</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="type">ServiceError</span>.<span class="type">OtherError</span>(resultCode: json[<span class="type">RESULT_CODE</span>].stringValue, resultMsg: json[<span class="type">RESULT_MSG</span>].stringValue)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">mapResponseToModel</span>&lt;T: HandyJSON&gt;<span class="params">(type: T.<span class="keyword">Type</span>)</span></span> -&gt; <span class="type">Observable</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">map</span>&#123; response <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">let</span> respContent = <span class="keyword">try</span> <span class="keyword">self</span>.preOrderCheck(response: response)</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">let</span> obj = <span class="type">T</span>.deserialize(from: respContent.rawString()) &#123;</span><br><span class="line">                        <span class="keyword">return</span> obj</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="type">ServiceError</span>.<span class="type">CouldNotMakeObjectError</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> <span class="keyword">let</span> err <span class="keyword">as</span> <span class="type">ServiceError</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> err</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">mapResponseToModelList</span>&lt;T: HandyJSON&gt;<span class="params">(type: T.<span class="keyword">Type</span>)</span></span> -&gt; <span class="type">Observable</span>&lt;[<span class="type">T</span>]&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">map</span>&#123; response <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> respContent = <span class="keyword">try</span> <span class="keyword">self</span>.preOrderCheck(response: response)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">let</span> objs = [<span class="type">T</span>].deserialize(from: respContent.rawString()) <span class="keyword">as</span>? [<span class="type">T</span>] &#123;</span><br><span class="line">                    <span class="keyword">return</span> objs</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="type">ServiceError</span>.<span class="type">CouldNotMakeObjectError</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> <span class="keyword">let</span> err <span class="keyword">as</span> <span class="type">ServiceError</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> err</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们就可以很轻松地写出这样的请求：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MovieProvider</span>.request(<span class="type">MovieApi</span>.cityList)</span><br><span class="line">    .mapResponseToModelList(type: <span class="type">MovieCity</span>.<span class="keyword">self</span>)</span><br><span class="line">    .subscribe(onNext: &#123; movieCitys <span class="keyword">in</span></span><br><span class="line">        </span><br><span class="line">    &#125;, onError: &#123; error <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(error)</span><br><span class="line">    &#125;).addDisposableTo(disposebag)</span><br></pre></td></tr></table></figure><p>非常简洁且高度可扩展，而且因为用了泛型，甚至可以不用做过多转换，得到的model list是直接可用的。</p><p>另外，值得一提的是，得益于Moya的灵活和扩展性，我们可以给Moya的provider做很多定制化，比如我这里的MovieProvider其实是这样的：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="type">MovieProvider</span> = <span class="type">RxMoyaProvider</span>&lt;<span class="type">MovieApi</span>&gt;(</span><br><span class="line">    endpointClosure: normalEndpointClosure(),</span><br><span class="line">    plugins: [<span class="type">NetworkLoggerPlugin</span>(verbose: <span class="literal">true</span>, cURL: <span class="literal">true</span>,responseDataFormatter: <span class="type">JSONResponseDataFormatter</span>)]</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>plugins</code>中Moya提供了打印网络请求参数的<code>NetworkLoggerPlugin</code>和网络状态控制的<code>NetworkActivityPlugin</code>，当然你也可以自己写一个Plugin</p><p><code>endpointClosure</code>这里可以去定制化一些http参数，比如header和common param，我写了一个比较共用的方法大概这样：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> headerFields: <span class="type">Dictionary</span>&lt;<span class="type">String</span>, <span class="type">String</span>&gt; = [</span><br><span class="line">    <span class="string">&quot;platform&quot;</span>: <span class="string">&quot;iOS&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Auth-Token&quot;</span>: <span class="string">&quot;get some token from your code&quot;</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> headerFieldsWithoutToken: <span class="type">Dictionary</span>&lt;<span class="type">String</span>, <span class="type">String</span>&gt; = [</span><br><span class="line">    <span class="string">&quot;platform&quot;</span>: <span class="string">&quot;iOS&quot;</span></span><br><span class="line">]</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">normalEndpointClosure</span>&lt;T: TargetType&gt;<span class="params">()</span></span> -&gt; ( (<span class="number">_</span> target: <span class="type">T</span>) -&gt; <span class="type">Endpoint</span>&lt;<span class="type">T</span>&gt;) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; (target: <span class="type">T</span>) -&gt; <span class="type">Endpoint</span>&lt;<span class="type">T</span>&gt; <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">let</span> appendedParams: <span class="type">Dictionary</span>&lt;<span class="type">String</span>, <span class="type">AnyObject</span>&gt; = [<span class="string">&quot;key&quot;</span> : <span class="string">&quot;somekey&quot;</span> <span class="keyword">as</span> <span class="type">AnyObject</span>]</span><br><span class="line">        <span class="keyword">let</span> fields:<span class="type">Dictionary</span>&lt;<span class="type">String</span>, <span class="type">String</span>&gt; = headerFields</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="type">Endpoint</span>&lt;<span class="type">T</span>&gt;(url: url(target), sampleResponseClosure: &#123;.networkResponse(<span class="number">200</span>, target.sampleData)&#125;, method: target.method, parameters: target.parameters)</span><br><span class="line">            .adding(newParameters: appendedParams)</span><br><span class="line">            .adding(newHTTPHeaderFields: fields)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如登录之后，可能需要在请求头加token或者每个请求参数带个token，就可以在这里统一添加。</p><p>嗯~大概就这么多。我会把总结的这部分内容写成一个<a href="https://github.com/KinoAndWorld/KONetworkLayerDemo">小demo</a>，算是一个小小的学习成果吧。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Swift上的常用第三方框架&quot;&gt;&lt;a href=&quot;#Swift上的常用第三方框架&quot; class=&quot;headerlink&quot; title=&quot;Swift上的常用第三方框架&quot;&gt;&lt;/a&gt;Swift上的常用第三方框架&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Alamofire&lt;br&gt;</summary>
      
    
    
    
    <category term="iOS" scheme="http://kinoandworld.github.io/categories/iOS/"/>
    
    
    <category term="Swift" scheme="http://kinoandworld.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift项目初体验琐记（1）</title>
    <link href="http://kinoandworld.github.io/2017/04/04/Swift%E9%A1%B9%E7%9B%AE%E5%88%9D%E4%BD%93%E9%AA%8C%E7%90%90%E8%AE%B0%EF%BC%881%EF%BC%89/"/>
    <id>http://kinoandworld.github.io/2017/04/04/Swift%E9%A1%B9%E7%9B%AE%E5%88%9D%E4%BD%93%E9%AA%8C%E7%90%90%E8%AE%B0%EF%BC%881%EF%BC%89/</id>
    <published>2017-04-03T16:54:50.000Z</published>
    <updated>2025-10-28T09:01:11.518Z</updated>
    
    <content type="html"><![CDATA[<p>虽说从Swift刚出生就一直有关注，但是由于ABI不稳定以及第三方支持还不够好等等原因，一直没有用于实际的真实项目中，直到3.0之后感觉时机成熟了，刚好最近有一个比较小的项目，于是有了一次实际项目的初体验，也顺便写下一些总结。（总体内容会比较浅显，惭愧了</p><h3 id="Swift与Objective-C常见写法差异"><a href="#Swift与Objective-C常见写法差异" class="headerlink" title="Swift与Objective-C常见写法差异"></a>Swift与Objective-C常见写法差异</h3><ol><li><p>判断字符串相等、==与===的区别<br> 在oc中，我们已经习惯了使用<code>isEqualToString</code>方法来判断两个字符串是否相等，似乎也不觉得有什么问题，这是因为oc使用<code>==</code>来统一引用的比较与值类型的比较，但是NSString在内存模型上比较特殊，以至于oc中使用了一个专门的比较方法，而在其他许多语言中只需要用<code>==</code>对比字符串就好。Swift改进了这一点，顺带一提，Swift中使用<code>==</code>来比较值类型是否相等，而使用<code>===</code>来判断引用类型是否相等。</p></li><li><p>数组遍历<br> 在oc中，我喜欢使用enumerateObjectsUsingBlock方法遍历数组并进行操作，大概是这个样子的：</p> <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *list = @[@<span class="number">1</span>,@<span class="number">2</span>,@<span class="number">3</span>,@<span class="number">4</span>,@<span class="number">5</span>];</span><br><span class="line">[list enumerateObjectsUsingBlock:^(<span class="keyword">id</span>  _Nonnull obj, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> * _Nonnull stop) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;obj = %@, idx = %d&quot;</span>, obj , (<span class="keyword">int</span>)idx);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p> 但是Swift自然不会还存在如此oc模样的方法，相替代的，Swift可以用foreach方法：</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> list = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">list.forEach &#123; number <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(number)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 但是如果我们想要像oc一样同时获取元素和下标的话，就要换一种写法了：</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> list = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">for</span> (idx, number) <span class="keyword">in</span> list.enumerated() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;idx is \(idx) and number is \(number)&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 无论如何，至少看起来比oc是要简洁多了。</p><p> 另外，Swift的一个令人激动的特色就是内嵌一些函数式编程范式，因此如果我们要对数组逐个进行操作的话用<code>map</code>方法是再方便不过。配合上一些语法糖，非常之简单而且直观，比如我们把上面的list的每个元素乘以2：</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(list.<span class="built_in">map</span> &#123; $<span class="number">0</span> * <span class="number">2</span> &#125;)</span><br></pre></td></tr></table></figure><p> 还有更多的基本用法如filter和reduce等等这里就不赘述了，很多<a href="%22https://yrq110.gitbooks.io/some_ios_tutorials_with_swift/content/Introduction%20to%20Functional%20Programming%20in%20Swift.html%22">相关教程</a>。</p></li><li><p>判断或获取类名字符串<br> 在oc中，获取一个对象的类型是很简单的，只需要调用class类型方法就好，比如<code>[AClass class]</code>，如果判断某个对象是否属于这个类型，则使用<code>isKindOfClass</code>方法：<code>[self isKindOfClass:[AClass class]]</code>，如果需要获取一个实例类名的字符串，则<code>NSStringFromClass([AClass class])</code>。而在Swift中，获取一个类的class很简单，只需要<code>AClass.self</code>就可以了，但是，如果你想获取一个实例对象的类名字符串，则需要这样写<code>String(describing: type(of: aInstance))</code>，额，总觉得有点奇怪。</p></li></ol><h3 id="Swift特性的一些实践经验总结"><a href="#Swift特性的一些实践经验总结" class="headerlink" title="Swift特性的一些实践经验总结"></a>Swift特性的一些实践经验总结</h3><ol><li><p>要说在Swift中最有特色体验最明显的，应该算可选类型了，诚然，可选类型可以帮助我们构建更安全更可靠的app，但是毫无疑问，可选类型中各种转换和拆包让人觉得略烦，特别是我这样的新手，稍不注意就是报错或者没有得到符合预期的值。然后在stackoverflow上看相关的讨论的时候，发现一个很有趣的小方法：</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Optional</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">valueOrDefault</span>&lt;T&gt;<span class="params">(defaultValue: T)</span></span> -&gt; <span class="type">T</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span>(<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> .<span class="keyword">none</span>:</span><br><span class="line">            <span class="keyword">return</span> defaultValue</span><br><span class="line">        <span class="keyword">case</span> .some(<span class="keyword">let</span> value):</span><br><span class="line">            <span class="keyword">return</span> value <span class="keyword">as</span>! <span class="type">T</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这是一个Optional类的扩展，用了泛型，代码就不解释了，很清晰。用上这个类别之后，我们可以方便的、安全的写这样的代码：</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a: <span class="type">Int?</span></span><br><span class="line"><span class="comment">//a = 1</span></span><br><span class="line"><span class="keyword">let</span> b = a.valueOrDefault(defaultValue: <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;b = \(b)&quot;</span>)</span><br></pre></td></tr></table></figure><p> 在不知道a是否有确切值的情况下，就可以将a安全的赋值给b，通过提供默认值的方式，简直赞。在这个例子中，如果把注释的那行取消注释，b则为1，在大量使用可选类型的基础上，使用这个小技巧可以避免使用一堆堆的诸如<code>if let b = a as? Int</code>的代码。</p></li><li><p>Swift与强大的枚举<br> 在oc或者说c中，枚举的用途也许仅仅是一个<em>同数据类型的常量集合</em>，但是在Swift中，枚举的能力被大大扩充，甚至完全可以替代简单的class。而且在一些方面的最佳实践中，枚举的出场率也相当高，比如notification.name。先不说有没有必要这样做，在我的实践中，发现Swift的枚举确实是一个很方便而且简化逻辑的玩意儿，还是举个栗子吧，比如我们有一个item，包含一个有3种状态的state变量，我们还需要根据这个state输出对应的颜色和说明文字等：</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Item</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">ItemState</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> success</span><br><span class="line">        <span class="keyword">case</span> fail</span><br><span class="line">        <span class="keyword">case</span> ready</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//inner function</span></span><br><span class="line">        <span class="function"><span class="keyword">func</span> <span class="title">showColor</span><span class="params">()</span></span>-&gt;<span class="type">UIColor</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">                <span class="keyword">case</span> .success: <span class="keyword">return</span> <span class="type">UIColor</span>.green</span><br><span class="line">                <span class="keyword">case</span> .fail: <span class="keyword">return</span> <span class="type">UIColor</span>.red</span><br><span class="line">                <span class="keyword">case</span> .ready: <span class="keyword">return</span> <span class="type">UIColor</span>.gray</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">func</span> <span class="title">descStr</span><span class="params">()</span></span>-&gt;<span class="type">String</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;[output: \(self)]&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&quot;example&quot;</span></span><br><span class="line">    <span class="keyword">var</span> state = <span class="type">ItemState</span>.ready</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 直接在enum中写function有什么好处呢？可以免去很多的判断，从而直接绑定输出，同时也减少了出错的机会，在这个例子中，我们可以如下调用：</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> item = <span class="type">Item</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;now state is = \(item.state.descStr()) , color is \(item.state.showColor())&quot;</span>)</span><br><span class="line">    </span><br><span class="line">item.state = .success</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;now state is = \(item.state.descStr()) , color is \(item.state.showColor())&quot;</span>)</span><br><span class="line">    </span><br><span class="line">item.state = .fail</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;now state is = \(item.state.descStr()) , color is \(item.state.showColor())&quot;</span>)</span><br></pre></td></tr></table></figure><p> 我们可以任意改变state，然后输出当前state对应的各种绑定变量，把逻辑内聚在enum中，外部的调用会非常顺畅。<br> 当然，这其实算是最基础的用法了，关于enum还有更多高级且高端的用法，可以参考<a href="%22http://swift.gg/2015/11/20/advanced-practical-enum-examples/%22">Swift 中枚举高级用法及实践</a></p></li><li><p>Swift中的反射<br> 从现状来看，Swift的动态性似乎是不如Objective-C的，某些诸如方法交换和动态绑定似乎底层用的也还是Objective-C的runtime。但是好在Swift还是有一个反射的替代方案，比较常用的一个地方就是，在需要保存一个NSObject对象到本地时，必须实现coder的相关方法，默认的做法是需要你把class内每个属性都分别写一个转换，非常麻烦而且容易出错，在Objective-C中可以通过运行时获取所有成员变量和类型来做这个事情，相对应的，Swift可以用Mirror：</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">convenience</span> <span class="keyword">required</span> <span class="keyword">init</span>?(coder aDecoder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">       <span class="keyword">self</span>.<span class="keyword">init</span>()</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> child <span class="keyword">in</span> <span class="type">Mirror</span>(reflecting: <span class="keyword">self</span>).children &#123;</span><br><span class="line">           <span class="keyword">if</span> <span class="keyword">let</span> key = child.label &#123;</span><br><span class="line">               setValue(aDecoder.decodeObject(forKey: key), forKey: key)</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">func</span> <span class="title">encode</span><span class="params">(with aCoder: NSCoder)</span></span> &#123;</span><br><span class="line">       <span class="keyword">for</span> child <span class="keyword">in</span> <span class="type">Mirror</span>(reflecting: <span class="keyword">self</span>).children &#123;</span><br><span class="line">           <span class="keyword">if</span> <span class="keyword">let</span> key = child.label &#123;</span><br><span class="line">               aCoder.encode(value(forKey: key), forKey: key)</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p> 还是比较方便快捷的，我们可以再优化一下，把这个放进NSObject的extension里，这样所有需要序列化的object就可以不用再繁复地一个个写了  :)</p></li></ol><p>下一篇我会总结一下目前用到的常用第三方框架和组合用法。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;虽说从Swift刚出生就一直有关注，但是由于ABI不稳定以及第三方支持还不够好等等原因，一直没有用于实际的真实项目中，直到3.0之后感觉时机成熟了，刚好最近有一个比较小的项目，于是有了一次实际项目的初体验，也顺便写下一些总结。（总体内容会比较浅显，惭愧了&lt;/p&gt;
&lt;h3 i</summary>
      
    
    
    
    <category term="iOS" scheme="http://kinoandworld.github.io/categories/iOS/"/>
    
    
    <category term="Swift" scheme="http://kinoandworld.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>从零开始开发一个App（3）- iOS客户端</title>
    <link href="http://kinoandworld.github.io/2016/08/05/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AAApp%EF%BC%883%EF%BC%89-iOS%E5%AE%A2%E6%88%B7%E7%AB%AF/"/>
    <id>http://kinoandworld.github.io/2016/08/05/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AAApp%EF%BC%883%EF%BC%89-iOS%E5%AE%A2%E6%88%B7%E7%AB%AF/</id>
    <published>2016-08-05T05:14:10.000Z</published>
    <updated>2025-10-28T09:01:11.519Z</updated>
    
    <content type="html"><![CDATA[<p>接上文，我们已经成功地在本地跑起了一个rails服务端，并且正确返回了JSON的接口数据，可以说万事俱备只欠客户端了。</p><p>终于来到了主战场，对我来说这是最繁琐但也是最简单的一步 :)</p><h3 id="工程搭建"><a href="#工程搭建" class="headerlink" title="工程搭建"></a>工程搭建</h3><p>二话不说，老规矩祭出Xcode，新建工程，新建Podfile</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">platform <span class="symbol">:ios</span>, <span class="string">&#x27;7.0&#x27;</span></span><br><span class="line"></span><br><span class="line">pod <span class="string">&#x27;Masonry&#x27;</span></span><br><span class="line">pod <span class="string">&#x27;BFKit&#x27;</span></span><br><span class="line"></span><br><span class="line">pod <span class="string">&#x27;ReactiveCocoa&#x27;</span></span><br><span class="line"></span><br><span class="line">pod <span class="string">&#x27;AFNetworking&#x27;</span></span><br><span class="line"></span><br><span class="line">pod <span class="string">&#x27;YYModel&#x27;</span></span><br><span class="line">pod <span class="string">&#x27;YYWebImage&#x27;</span></span><br></pre></td></tr></table></figure><p>然后安装<code>pod install</code></p><h3 id="界面布局"><a href="#界面布局" class="headerlink" title="界面布局"></a>界面布局</h3><p>我们可以先完成简单的页面布局，由于目前的数据非常单一，所以也就简单单页面实现，以一个CollectionView作为主控件，每个评测一个cell。</p><p>新增<code>ReviewListView</code>继承自UICollectionView，自定义UICollectionViewFlowLayout子类<code>ReviewListViewLayout</code>，然后用<code>Masonry</code>手写布局。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ReviewListView *colview = [[ReviewListView alloc] init];</span><br><span class="line">colview.delegate = <span class="keyword">self</span>;</span><br><span class="line">colview.dataSource = <span class="keyword">self</span>;</span><br><span class="line">[colview <span class="symbol">registerClass:</span>[ReviewSummaryCell <span class="class"><span class="keyword">class</span>] <span class="title">forCellWithReuseIdentifier</span>:@&quot;<span class="title">ReviewSummaryCell</span>&quot;];</span></span><br><span class="line">    </span><br><span class="line">_reviewListView = colview;</span><br><span class="line">[<span class="keyword">self</span>.view <span class="symbol">addSubview:</span>_reviewListView];</span><br><span class="line">    </span><br><span class="line">[_reviewListView <span class="symbol">mas_makeConstraints:</span>^(MASConstraintMaker *make) &#123;</span><br><span class="line">    make.edges.equalTo(<span class="keyword">self</span>.view);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>接着实现UICollectionViewDataSource的代理方法，这个时候需要新建UICollectionViewCell的子类<code>ReviewSummaryCell</code>，然后手写添加控件，完成基本布局。</p><p>自此，一个简单的页面搭建已经完成，下面是数据请求的接入。</p><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>网络层是在基于<em>AFNetworkKit</em>的基础上，连接数据请求模块和ViewController的中间层，我稍微封装了一下，详细的代码可以在文末的源码连接查看。</p><p>大致步骤是新建一个<code>ReviewApiEngine</code>类，继承自<code>BaseApiEngine</code></p><p>网络请求大致代码如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  获取评测列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="keyword">void</span>)fetchFeatureListWithSuccessHandler:(ResponseBlock)completeBlock</span><br><span class="line">                              errorHandler:(ErrorBlock)errorBlock</span><br><span class="line">                                translater:(Class&lt;DataTranslate&gt;)translater&#123;</span><br><span class="line">    </span><br><span class="line">    [[APIManager shareManager] sendRequestFromMethod:APIMethodGet</span><br><span class="line">                                                path:API_ReviewList</span><br><span class="line">                                              params:<span class="literal">nil</span></span><br><span class="line">                                          onComplete:Default_Handle</span><br><span class="line">                                             onError:errorBlock];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后在controller只需要调用</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (void)fetchData&#123;</span><br><span class="line">    useWeakSelf</span><br><span class="line">    [ReviewApiEngine <span class="symbol">fetchReviewListWithSuccessHandler:</span>^(id responseResult) &#123;</span><br><span class="line">        </span><br><span class="line">        [weakSelf.reviewListView reloadData];</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="symbol">errorHandler:</span>^(NSError *error) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="symbol">translater:</span>[GameReview <span class="class"><span class="keyword">class</span>]];</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>便可以轻松完成网络数据请求的任务。</p><p>我们可以先写测试或者在App生命周期中先调用网络请求，确保能正确无误地拿到数据。<br>一切准备就绪后，我们在<code>ReviewSummaryCell</code>中添加配置方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (void)configWithIndexPath:(NSIndexPath *)indexPath model:(GameReview *)review&#123;</span><br><span class="line">    </span><br><span class="line">    [_thumbImageView setImageURL:[NSURL URLWithString:review.cover_image]];</span><br><span class="line">    </span><br><span class="line">    _titleLabel.text &#x3D; review.title;</span><br><span class="line">    </span><br><span class="line">    _summaryLabel.text &#x3D; review.summary;</span><br><span class="line">    </span><br><span class="line">    _scoreView.score &#x3D; review.score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终完成效果如图：</p><p><img src="http://upload-images.jianshu.io/upload_images/25038-1570b079cf488d95.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="模拟器截图"></p><h3 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h3><p>这个实践对我来说是一次非常有意义的技术探索，扩展起来，我们可以发挥更多想象力做更多有趣以及有意义的事情，技术改变生活不应是一句口号，而应当是我们行动的信念。</p><p>好了，打完收工。</p><p>所有的源代码放在<a href="https://github.com/KinoAndWorld/YouxiaReview">这里</a>。</p><p>→_→</p><hr><p><strong>系列链接</strong></p><a href="/2016/08/01/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AAApp%EF%BC%881%EF%BC%89-Scrapy%E7%88%AC%E8%99%AB/" title="从零开始开发一个App（1）- Scrapy爬虫">从零开始开发一个App（1）- Scrapy爬虫</a><a href="/2016/08/03/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AAApp%EF%BC%882%EF%BC%89-%E7%AE%80%E6%98%93REST-API%E6%9C%8D%E5%8A%A1%E7%AB%AF/" title="从零开始开发一个App（2）- 简易REST API服务端">从零开始开发一个App（2）- 简易REST API服务端</a><a href="/2016/08/05/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AAApp%EF%BC%883%EF%BC%89-iOS%E5%AE%A2%E6%88%B7%E7%AB%AF/" title="从零开始开发一个App（3）- iOS客户端">从零开始开发一个App（3）- iOS客户端</a>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;接上文，我们已经成功地在本地跑起了一个rails服务端，并且正确返回了JSON的接口数据，可以说万事俱备只欠客户端了。&lt;/p&gt;
&lt;p&gt;终于来到了主战场，对我来说这是最繁琐但也是最简单的一步 :)&lt;/p&gt;
&lt;h3 id=&quot;工程搭建&quot;&gt;&lt;a href=&quot;#工程搭建&quot; class</summary>
      
    
    
    
    <category term="技术杂谈" scheme="http://kinoandworld.github.io/categories/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/"/>
    
    
  </entry>
  
  <entry>
    <title>从零开始开发一个App（2）- 简易REST API服务端</title>
    <link href="http://kinoandworld.github.io/2016/08/03/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AAApp%EF%BC%882%EF%BC%89-%E7%AE%80%E6%98%93REST-API%E6%9C%8D%E5%8A%A1%E7%AB%AF/"/>
    <id>http://kinoandworld.github.io/2016/08/03/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AAApp%EF%BC%882%EF%BC%89-%E7%AE%80%E6%98%93REST-API%E6%9C%8D%E5%8A%A1%E7%AB%AF/</id>
    <published>2016-08-03T05:33:20.000Z</published>
    <updated>2025-10-28T09:01:11.519Z</updated>
    
    <content type="html"><![CDATA[<p>上篇文章讲到使用scrapy爬虫轻而易举地爬取到了我们需要的数据内容，并且已经保存在本地文件中。这一篇，我们换一个姿势，开启rails服务端之旅。</p><h3 id="安装与初始化"><a href="#安装与初始化" class="headerlink" title="安装与初始化"></a>安装与初始化</h3><p>rails环境的安装，称不上特别简单，但也不难。我也是照本宣科的，甩一个教程就好 <a href="https://ruby-china.org/wiki/install_ruby_guide">如何快速正确的安装 Ruby, Rails 运行环境</a></p><p>安装好之后，跟scrapy爬虫一样，我们只需要在命令行用一行代码创建工程。</p><p>首先创建一个<code>yx_review_server</code>目录并进入，<br>然后</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rails new yx_review</span><br></pre></td></tr></table></figure><p>稍候片刻，一个完整的工程拔地而起，巍峨地竖立在终端之巅。</p><p><img src="http://upload-images.jianshu.io/upload_images/25038-5d1c003336c618d3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Atom IDE"></p><h3 id="数据导入"><a href="#数据导入" class="headerlink" title="数据导入"></a>数据导入</h3><p>首先，跟爬虫一样，我们先建一个model，字段照搬。而在rails中这个任务只需要一行代码就可以完成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rails g model review title cover_image summary score</span><br></pre></td></tr></table></figure><p>更令人亦可赛艇的地方就是，rails中的model与数据库是无缝连接的，只要配置好数据库设置，model的创建与获取等在底层与数据库交互的细节是完全透明的。</p><p>创建好model之后，我们打开目录下的<code>db/seed.rb</code>文件，将之前的json文件作为数据库初始种子，写入数据库中：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">local_path = <span class="string">&quot;/Users/Kino/Development/YouxiaReview/yxReview/items.json&quot;</span></span><br><span class="line">records = JSON.parse(File.read(local_path))</span><br><span class="line">records.each <span class="keyword">do</span> <span class="params">|record|</span></span><br><span class="line">  Review.create!(<span class="symbol">title:</span> record[<span class="string">&#x27;title&#x27;</span>],</span><br><span class="line">    <span class="symbol">cover_image:</span> record[<span class="string">&#x27;cover_image&#x27;</span>],</span><br><span class="line">    <span class="symbol">summary:</span> record[<span class="string">&#x27;summary&#x27;</span>],</span><br><span class="line">    <span class="symbol">score:</span> record[<span class="string">&#x27;score&#x27;</span>])</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>为了简单起见，这里的local_path我直接用本地的绝对路径。<br>接下来，我们在终端输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rake db:migrate</span><br><span class="line"></span><br><span class="line">rake db:seed</span><br></pre></td></tr></table></figure><p>分别进行数据库的迁移与种子数据的载入，相当于根据model在本地创建数据库并写入一些初始数据。</p><p>如果需要测试数据库是否成功创建并写入数据，可以在终端输入<code>rails console</code>然后输入<code>Review.all</code>查看是否打印出对应的数据。</p><p>到这一步，前期准备工作就正式完成了。</p><hr><h3 id="API接口"><a href="#API接口" class="headerlink" title="API接口"></a>API接口</h3><p>所谓工欲善其事必先利其器，在rails中，有个叫<code>grape</code>的库专门用于API接口的编写REST API，于是我们先装为敬。<br>打开根目录下的Gemfile文件，并添加一行<code>gem &#39;grape&#39;</code></p><p>然后终端中输入<code>bundle install</code>进行安装。</p><p>安装完成后，在编写api之前，我们先在<code>config/application.rb</code>中加入下面两行，以便rails程序能识别并载入我们的api文件夹</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">config.paths.add File.join(<span class="string">&#x27;app&#x27;</span>, <span class="string">&#x27;api&#x27;</span>), <span class="symbol">glob:</span> File.join(<span class="string">&#x27;**&#x27;</span>, <span class="string">&#x27;*.rb&#x27;</span>)</span><br><span class="line">config.autoload_paths += Dir[Rails.root.join(<span class="string">&#x27;app&#x27;</span>, <span class="string">&#x27;api&#x27;</span>, <span class="string">&#x27;*&#x27;</span>)]</span><br></pre></td></tr></table></figure><p>然后进入app目录，创建api目录并创建<code>api.rb</code>如下：</p><p><img src="http://upload-images.jianshu.io/upload_images/25038-566852cd607b74e8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="api目录结构"></p><p><code>api.rb</code>编辑内容如下</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">API</span> &lt; Grape::API</span></span><br><span class="line">  format <span class="symbol">:json</span></span><br><span class="line">  prefix <span class="string">&#x27;api&#x27;</span></span><br><span class="line">  version <span class="string">&#x27;v1&#x27;</span>, <span class="symbol">using:</span> <span class="symbol">:path</span></span><br><span class="line"></span><br><span class="line">  resource <span class="symbol">:reviews</span> <span class="keyword">do</span></span><br><span class="line">    desc <span class="string">&quot;List all review&quot;</span></span><br><span class="line">    get <span class="keyword">do</span></span><br><span class="line">      Review.all</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这里声明了数据格式为json，并且指定resource为reviews，使用get方法返回数据库中所有的<code>Review.all</code>对象。</p><p>由于目前的数据量非常少，我这里为了简（tou）单（lan）直接返回了所有数据，在一般情况下都是需要排序和分页的，大致是这个样子：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">params <span class="keyword">do</span></span><br><span class="line">  requires <span class="symbol">:page</span>, <span class="symbol">:type</span> =&gt;Integer, <span class="symbol">:desc</span> =&gt; <span class="string">&quot;page&quot;</span></span><br><span class="line">  requires <span class="symbol">:size</span>, <span class="symbol">:type</span> =&gt;Integer, <span class="symbol">:desc</span> =&gt; <span class="string">&quot;size&quot;</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">get <span class="keyword">do</span></span><br><span class="line">  Review.order(<span class="symbol">created_at:</span> <span class="symbol">:desc</span>).page(params[<span class="symbol">:page</span>]).per(params[<span class="symbol">:size</span>])</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>在这个时候rails的路由还没能识别到api接口，我们需要在根目录下的<code>config/routes.rb</code>中加入</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount API =&gt; <span class="string">&#x27;/&#x27;</span></span><br></pre></td></tr></table></figure><p>然后一切准备就绪，我们在终端中输入 <code>rails server</code>将服务器跑起来。</p><p>如无意外，rails将在本地建立一个监听端口3000的服务端，我们在浏览器中输入<br><code>http://localhost:3000/api/v1/reviews</code></p><p><img src="http://upload-images.jianshu.io/upload_images/25038-76f1936ec87800e0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="浏览器访问截图"></p><h3 id="里程碑"><a href="#里程碑" class="headerlink" title="里程碑"></a>里程碑</h3><p>作为一个极简实现，它的本身存在诸多不完善，比如api分版本分结构的需要，比如接口带参数以及验证的需要等等。但是对于一个iOS开发者以及服务端小白来说，这是具有里程碑的意义的，下一篇，回到iOS的主战场，快速构建一个炫酷(并不)的App。</p><hr><p>参考Link：</p><p><a href="https://ruby-china.org/wiki/install_ruby_guide">如何快速正确的安装 Ruby, Rails 运行环境</a></p><p><a href="http://www.runoob.com/ruby/ruby-json.html">Ruby JSON</a></p><p><a href="https://ihower.tw/rails4/index.html">Ruby on Rails 實戰聖經</a></p><p><a href="https://www.sitepoint.com/build-great-apis-grape/">Build Great APIS with Grape</a></p><hr><p><strong>系列链接</strong></p><a href="/2016/08/01/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AAApp%EF%BC%881%EF%BC%89-Scrapy%E7%88%AC%E8%99%AB/" title="从零开始开发一个App（1）- Scrapy爬虫">从零开始开发一个App（1）- Scrapy爬虫</a><a href="/2016/08/03/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AAApp%EF%BC%882%EF%BC%89-%E7%AE%80%E6%98%93REST-API%E6%9C%8D%E5%8A%A1%E7%AB%AF/" title="从零开始开发一个App（2）- 简易REST API服务端">从零开始开发一个App（2）- 简易REST API服务端</a><a href="/2016/08/05/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AAApp%EF%BC%883%EF%BC%89-iOS%E5%AE%A2%E6%88%B7%E7%AB%AF/" title="从零开始开发一个App（3）- iOS客户端">从零开始开发一个App（3）- iOS客户端</a>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;上篇文章讲到使用scrapy爬虫轻而易举地爬取到了我们需要的数据内容，并且已经保存在本地文件中。这一篇，我们换一个姿势，开启rails服务端之旅。&lt;/p&gt;
&lt;h3 id=&quot;安装与初始化&quot;&gt;&lt;a href=&quot;#安装与初始化&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="技术杂谈" scheme="http://kinoandworld.github.io/categories/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/"/>
    
    
  </entry>
  
  <entry>
    <title>从零开始开发一个App（1）- Scrapy爬虫</title>
    <link href="http://kinoandworld.github.io/2016/08/01/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AAApp%EF%BC%881%EF%BC%89-Scrapy%E7%88%AC%E8%99%AB/"/>
    <id>http://kinoandworld.github.io/2016/08/01/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AAApp%EF%BC%881%EF%BC%89-Scrapy%E7%88%AC%E8%99%AB/</id>
    <published>2016-08-01T10:18:42.000Z</published>
    <updated>2025-10-28T09:01:11.519Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近我体验了一次全栈（伪）开发App的经历，获益良多，我想把过程记录一下，一是回顾与巩固，二是抛砖引玉，如有谬误以求大神指点。</p><p>首先，我们需要明确我们最终的目标是什么。<br>比如现在我要做一个简单的游戏评测资讯的App。<br>那么我首先需要【数据来源】然后需要一个提供数据接口的【服务端】，我将先完成这二者，然后才开始App的开发。</p><p>因此我将分为三步[Python爬虫]-&gt;[Ruby服务端]-&gt;[iOS客户端]来完成这个App。</p><p>而爬虫技术，将作为先遣部队，为我们攻下第一个数据堡垒。</p><h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>许多语言都有成熟的爬虫框架，我选择的是使用Python语言的Scrapy框架，这是一个非常完善而且功能强大的爬虫框架，我们只需要用到最基础的功能。Scrapy拥有非常棒的<a href="http://scrapy-chs.readthedocs.io/zh_CN/0.24/index.html">中文文档</a> 安装和入门教程文档一应俱全，我就不赘述了。</p><p>安装好之后，我们打开终端，开始创建令人激动的爬虫</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scrapy startproject yxReview</span><br><span class="line"></span><br><span class="line">cd yxReview </span><br><span class="line"></span><br><span class="line">scrapy genspider yx_review www.ali213.net&#x2F;news&#x2F;pingce</span><br></pre></td></tr></table></figure><p>完成后结构大致如图<br><img src="http://upload-images.jianshu.io/upload_images/25038-3289227b3c31677b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="k"></p><p>就这样，基础的框架和代码已经被生成了，接着我们用编辑器打开yxReview目录，首先在<code>items.py</code>文件下新建一个item。<br>我们可以先打开网页<a href="http://www.ali213.net/news/pingce/">游侠评测</a>分析一下</p><p><img src="http://upload-images.jianshu.io/upload_images/25038-c322d36580a526ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="游侠评测"></p><p>简单起见，我们目前只抓取4个属性，创建代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArticleItem</span>(<span class="params">scrapy.Item</span>):</span></span><br><span class="line">    title = scrapy.Field()</span><br><span class="line">    cover_image = scrapy.Field()</span><br><span class="line">    summary = scrapy.Field()</span><br><span class="line">    score = scrapy.Field()</span><br></pre></td></tr></table></figure><p>然后我们进入目录下的spiders文件夹，打开<code>yx_review.py</code><br>如下编辑</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> yxReview.items <span class="keyword">import</span> ArticleItem</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">YxReviewSpider</span>(<span class="params">scrapy.Spider</span>):</span></span><br><span class="line">    name = <span class="string">&quot;yx_review&quot;</span></span><br><span class="line">    allowed_domains = [<span class="string">&quot;www.ali213.net&quot;</span>]</span><br><span class="line">    start_urls = (</span><br><span class="line">        <span class="string">&#x27;http://www.ali213.net/news/pingce/&#x27;</span>,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span>(<span class="params">self, response</span>):</span></span><br><span class="line">        items = []</span><br><span class="line">        <span class="keyword">for</span> sel <span class="keyword">in</span> response.xpath(<span class="string">&#x27;//div[@class=&quot;t3_l_one_l&quot;]&#x27;</span>):</span><br><span class="line">            item = ArticleItem()</span><br><span class="line">            item[<span class="string">&quot;cover_image&quot;</span>] = sel.xpath(<span class="string">&quot;div[@class=&#x27;one_l_pic&#x27;]/a/img/@src&quot;</span>).extract()</span><br><span class="line">            item[<span class="string">&quot;title&quot;</span>] =   sel.xpath(<span class="string">&quot;div[@class=&#x27;one_l_con&#x27;]/div[@class=&#x27;one_l_con_tit&#x27;]/a/text()&quot;</span>).extract()</span><br><span class="line">            item[<span class="string">&quot;summary&quot;</span>] = sel.xpath(<span class="string">&quot;div[@class=&#x27;one_l_con&#x27;]/div[@class=&#x27;one_l_con_con&#x27;]/text()&quot;</span>).extract()</span><br><span class="line">            items.append(item)</span><br><span class="line"></span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> scoreSel <span class="keyword">in</span> response.xpath(<span class="string">&#x27;//div[@class = &quot;t3_l_one_r&quot;]&#x27;</span>):</span><br><span class="line">            item = items[index]</span><br><span class="line">            item[<span class="string">&quot;score&quot;</span>] = scoreSel.xpath(<span class="string">&quot;div/span/text()&quot;</span>).extract()</span><br><span class="line">            index = index + <span class="number">1</span></span><br><span class="line">            <span class="keyword">yield</span> item</span><br><span class="line"></span><br><span class="line">        <span class="keyword">print</span> items</span><br></pre></td></tr></table></figure><p>这里主要是parse方法，返回请求到的HTML然后解析出我们需要的数据装进ArticleItem里，然后将items传输到<code>pipeline</code>中。</p><h3 id="传输管道"><a href="#传输管道" class="headerlink" title="传输管道"></a>传输管道</h3><p>在爬虫scrapy中，pipeline是一个重要的概念，它相当于一个“加工器”，可以连接多个自定义的pipeline，完成数据的后续处理工作，比如进行筛选分类，或者持久化到本地等等，按优先级串连。</p><p>在本例中，为了简便，我将创建一个管道将数据简单处理并保存到本地文件中。</p><p>打开<code>pipelines.py</code>，编辑如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> scrapy <span class="keyword">import</span> signals</span><br><span class="line"><span class="keyword">from</span> scrapy.contrib.exporter <span class="keyword">import</span> JsonItemExporter</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">YxreviewPipeline</span>(<span class="params">object</span>):</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">from_crawler</span>(<span class="params">cls, crawler</span>):</span></span><br><span class="line">         pipeline = cls()</span><br><span class="line">         crawler.signals.connect(pipeline.spider_opened, signals.spider_opened)</span><br><span class="line">         crawler.signals.connect(pipeline.spider_closed, signals.spider_closed)</span><br><span class="line">         <span class="keyword">return</span> pipeline</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spider_opened</span>(<span class="params">self, spider</span>):</span></span><br><span class="line">        self.file = open(<span class="string">&#x27;items.json&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line">        self.exporter = JsonItemExporter(self.file)</span><br><span class="line">        self.exporter.start_exporting()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spider_closed</span>(<span class="params">self, spider</span>):</span></span><br><span class="line">        self.exporter.finish_exporting()</span><br><span class="line">        self.file.close()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_item</span>(<span class="params">self, item, spider</span>):</span></span><br><span class="line">        self.checkData(item, <span class="string">&quot;title&quot;</span>)</span><br><span class="line">        self.checkData(item, <span class="string">&quot;summary&quot;</span>)</span><br><span class="line">        self.checkData(item, <span class="string">&quot;cover_image&quot;</span>)</span><br><span class="line">        self.checkData(item, <span class="string">&quot;score&quot;</span>)</span><br><span class="line"></span><br><span class="line">        self.exporter.export_item(item)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkData</span>(<span class="params">self ,item, field</span>):</span></span><br><span class="line">        <span class="keyword">if</span> len(item[field]) &gt; <span class="number">0</span>:</span><br><span class="line">            newText = item[field][<span class="number">0</span>].encode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">            item[field] = newText.strip()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            item[field] = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>前面三个方法，相当于给当前的pipeline提供了一个JsonItemExporter的插件，用于将所有爬取的item导出为JSON格式的文件之中。</p><p>另外需要说明的是，这里自定义了一个<code>checkData</code>方法，作为一个简单的数据类型验证，以及将之前解析的内容转换成字符串并且进行了utf-8编码的转码，保障中文内容的正确显示。</p><p>完成后，打开工程目录下的<code>items.json</code>文件，可以看到数据已经以JSON格式保存了下来。</p><p><img src="http://upload-images.jianshu.io/upload_images/25038-5309230be55509fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="items.json"></p><h3 id="告一段落"><a href="#告一段落" class="headerlink" title="告一段落"></a>告一段落</h3><p>至此，爬虫的任务可以告一段落，当然，在实际应用中还需要解决更多的问题，比如分页爬取，反爬虫的应对等等，迫于文章篇幅暂且不表，算作扩展阅读吧 ：）</p><p>下一篇，我们将使用ruby on rails编写服务端，提供移动端的REST API接口。</p><hr><p><strong>系列链接</strong></p><a href="/2016/08/01/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AAApp%EF%BC%881%EF%BC%89-Scrapy%E7%88%AC%E8%99%AB/" title="从零开始开发一个App（1）- Scrapy爬虫">从零开始开发一个App（1）- Scrapy爬虫</a><a href="/2016/08/03/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AAApp%EF%BC%882%EF%BC%89-%E7%AE%80%E6%98%93REST-API%E6%9C%8D%E5%8A%A1%E7%AB%AF/" title="从零开始开发一个App（2）- 简易REST API服务端">从零开始开发一个App（2）- 简易REST API服务端</a><a href="/2016/08/05/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AAApp%EF%BC%883%EF%BC%89-iOS%E5%AE%A2%E6%88%B7%E7%AB%AF/" title="从零开始开发一个App（3）- iOS客户端">从零开始开发一个App（3）- iOS客户端</a>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;最近我体验了一次全栈（伪）开发App的经历，获益良多，我想把过程记录一下，一是回顾与巩固，二是抛砖引玉，如有谬误以求大神指点。&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    <category term="技术杂谈" scheme="http://kinoandworld.github.io/categories/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/"/>
    
    
  </entry>
  
  <entry>
    <title>深圳2016-hackathon记录</title>
    <link href="http://kinoandworld.github.io/2016/06/25/2016-06-25-2016-shenzhen-hackaton-record/"/>
    <id>http://kinoandworld.github.io/2016/06/25/2016-06-25-2016-shenzhen-hackaton-record/</id>
    <published>2016-06-24T18:55:23.000Z</published>
    <updated>2025-10-28T09:01:11.517Z</updated>
    
    <content type="html"><![CDATA[<h3 id="初来乍到"><a href="#初来乍到" class="headerlink" title="初来乍到"></a>初来乍到</h3><p>知道这个活动是一个在佛山的小伙伴邀请我一起参加，以前对黑客马拉松一直神往但总没机会尝试，于是抱着有些事现在不做就一辈子都不会做了的心态，我跟他还有另外两个95后小伙伴相约一起，朝深圳粗发。<br>从广州到深圳，我第一次体验顺风车，直接到会场而且价格比高铁便宜很多，很赞。</p><h3 id="头脑风暴"><a href="#头脑风暴" class="headerlink" title="头脑风暴"></a>头脑风暴</h3><p>题目是这样：url<br>拿到题目，我们4个人迅速头脑风暴了一下。<br>想到达芬奇，最耳熟能详的当然就是那副名画《蒙娜丽莎的微笑》，然后很迅速地，我想到一个idea。就是通过人脸识别，把自拍或者照片的笑脸替换成蒙娜丽莎的微笑，蜜汁喜感。但是考虑到实现的话，我们一时之间没有多大头绪，因为这需要动态的图形拼贴等处理，我们并不精于此道。好在得到这个灵感，我们迅速想到了另一个idea——做一个自拍表情PK的App。大致原理就是，通过表情识别，我们可以为一张照片评出他的情绪以及程度，这时候我们让两个人上传他们的自拍，然后对决PK，通过识别结果判断胜负。在我们一致认可这个idea之后，我给这次的项目取了个名字 FaceBattle。</p><h3 id="开始coding"><a href="#开始coding" class="headerlink" title="开始coding"></a>开始coding</h3><p>在丰盛的午餐以及下午茶的陪伴下，我们开始迅速讨论作战方案，由于我们4个人刚好是一个iOS，一个Android，一个UWP（😄情怀），还有一个服务端，简直一不小心就全平台了😂。当然，在开发之前，我们在纸上讨论了大致了原型以及需要的接口，然后负责WP的超哥也有模有样地迅速撸了几个界面。大家都像打了鸡血一样，争分夺秒这个词无比恰当地装饰着周遭的气氛中。</p><h3 id="不眠之夜"><a href="#不眠之夜" class="headerlink" title="不眠之夜"></a>不眠之夜</h3><p>俗话说得好，人生不如意之事十之八九。随着时间的推进，疲惫使我们渐渐力有未逮，而且在服务端与微软的表情识别接口的联调上也出现了一些问题，直到晚上，我们的进度开始捉襟见肘。吃完了棒呆的夜宵，困意如约而至，而我们唯有用意志对抗阻力，注定在这个不眠不夜继续开发与调试。<br>在我们的努力“马拉松”下，终于把APP完成了八九不离十的程度，小憩一会之后，太阳冉冉升起，晨曦笼罩了大地。</p><h3 id="路演"><a href="#路演" class="headerlink" title="路演"></a>路演</h3><p>到了中午就是“是骡子是马拉出来溜溜”的路演环节了，这次一共有12支队伍参赛，有一些经验十足的队伍，还有几个外国友人组成的队伍，说实话还是蛮有压力的。轮到我们解说作品的时候，我先扯了我们作品与文艺复兴的关系（因为这次马拉松的主题和参赛题目都跟文艺复兴有关），然后演示了在不同平台上进行battle的场景，当我看到在场的观众因为我们的新意而感到好奇和愉悦的时候，顿时觉得无论得奖与否，我们的作品已经发挥了应有的价值：）<br>最后出乎意料地，我们拿到了二等奖，并且与最佳人气奖只有一票之差，第一次参加能有这样的成绩说实话我已经非常知足了（果然抱对了大腿的感觉）。</p><h3 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h3><p>我想这次经历无论对我还是另外几个小伙伴，都是宝贵的人生财富，而且我们本身也学到了很多。当然对我来说，更值得高兴的是又交到了几个志同道合的朋友。<br>最后，把我们的些许劳动成果开源一下，虽然时间有限可能质量并不是很好。</p><p><a href="https://github.com/JuniperPhoton/FaceBattleUWP">https://github.com/JuniperPhoton/FaceBattleUWP</a> （WP版，里面还有设计稿）</p><p><a href="https://github.com/KinoAndWorld/FaceBattle">https://github.com/KinoAndWorld/FaceBattle</a> （iOS版）</p><p>还有 微软的<a href="%E7%89%9B%E6%B4%A5%E8%AE%A1%E5%88%92">https://www.azure.cn/cognitive-services</a>是很棒的东西。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;初来乍到&quot;&gt;&lt;a href=&quot;#初来乍到&quot; class=&quot;headerlink&quot; title=&quot;初来乍到&quot;&gt;&lt;/a&gt;初来乍到&lt;/h3&gt;&lt;p&gt;知道这个活动是一个在佛山的小伙伴邀请我一起参加，以前对黑客马拉松一直神往但总没机会尝试，于是抱着有些事现在不做就一辈子都不会</summary>
      
    
    
    
    <category term="iOS" scheme="http://kinoandworld.github.io/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>机器与心——读《机器人短篇全集》</title>
    <link href="http://kinoandworld.github.io/2016/06/11/%E6%9C%BA%E5%99%A8%E4%B8%8E%E5%BF%83%E2%80%94%E2%80%94%E8%AF%BB%E3%80%8A%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9F%AD%E7%AF%87%E5%85%A8%E9%9B%86%E3%80%8B/"/>
    <id>http://kinoandworld.github.io/2016/06/11/%E6%9C%BA%E5%99%A8%E4%B8%8E%E5%BF%83%E2%80%94%E2%80%94%E8%AF%BB%E3%80%8A%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9F%AD%E7%AF%87%E5%85%A8%E9%9B%86%E3%80%8B/</id>
    <published>2016-06-11T04:31:15.000Z</published>
    <updated>2025-10-28T09:01:11.520Z</updated>
    
    <content type="html"><![CDATA[<p>首先，提到阿西莫夫老人家，最最出名也是不得不提的就是</p><p>机器人学三大定律</p><pre><code>机器人不得伤害人类，或因不作为而使人类受到伤害。除非违背第一法则，机器人必须服从人类的命令。在不违背第一及第二法则的情况下，机器人必须保护自己。</code></pre><p>可以说，这本短篇集的核心正是围绕着这三原则来进行的（当然严格来说并不是，某些短篇比较随意而且偶有违背三原则的故事）</p><p>短篇中最精彩的部分在于三原则自身的冲突和漏洞，其实可以把很多短篇当成一个推理故事在看，而三定律则是一个共知的背景设定。</p><p>我稍微讲一下我觉得比较有趣的或者经典的故事 ：）</p><p>###无心插柳<br>在故事无心的胜利中，讲述的是与木星人接触的两个人造机器人的故事，木星人拥有巨大的资源和强大的科技，以及强大的种族优越感。讽刺的是，木星人错把不需供氧不惧压强能直接在大气生存的机器人当成了人类，在机器人的<strong>强大</strong>面前，木星人放弃了摧毁人类的计划，更讽刺的是，人类靠着自己创造的却比自己更优越的物种逃过了一劫。</p><p>###叛乱的机器人<br>在短篇《消失无踪》中，则主要讲述了人与智能机器人的冲突。在第一原则遭到削弱的情况下，机器人的野心开始萌芽。如果没有对人类的绝对服从，机器人的求生欲和对自由的渴求其实已经注定了他们的叛变。类似的，在短篇《机器人之梦》中，一个机器人梦到自己变成了人，想要去拯救被人类奴役的机器人同胞。当开始思考自己究竟为何物，便会为了自己的福祉和自由而奋斗而不是所谓的造物主，人与机器人都是如此。当然，最终他们的结局一定是被人类灭亡，我们肯定人性，却不能容忍机器人有了人性，因为我们必须承认，机器人在种种方面优越于人类，这也是当今或今后我们必须警惕人工智能的原因。</p><p>###人性与机器之心<br>《汝竟顾念他》主要描述了两个优秀智能机器人之间的对话，他们探讨到了“何为人”这个很哲学的话题，因为当智能机器人发展到一定程度，无论心灵还是肉体，机器人都不亚于人类甚至在人类之上，这让他们对人类的定义产生了怀疑。他们认为机器人也是人类，并且是更高等的人类，因此在服从三大原则的情况下，机器人可以悄无声息的对抗人类，而不用冒着正子脑被烧毁的风险。真是细思极恐，btw，阿西莫夫老人家还真喜欢找三大定律的漏洞 ：）</p><p>而在《双百人》中，则讲述了对人类尽忠职守的机器管家，穷尽一生只渴望成为人类，为了追逐人性的光辉，他改造自己的身体，学习人类的动作和语调，成为了不管是人类还是机器人眼中的怪胎，受尽凌辱和嘲笑，然而他的欲望是如此强烈，不屈不挠地争取了数十年之后，终于成为了一个受到人类认可的人类，而代价就是死亡——也是作为一个真正人类的结局。</p><p>###最后<br>我们既渴望一个更高度的智慧来为人类解决问题，又渴望这个高度智慧的大脑无条件服从人类，这或许有鱼与熊掌兼得之虞。而在人工智能的迅速发展中，机器人与人类的界限会越来越小甚至变得模糊，人与机器人之间微妙的关系既令人激动又惹人担忧。或许有些杞人忧天，毕竟这一天距离现在还有一段不短的距离，但是怀着对未来的期待，我希望这一天早点到来。<br>又或者，某一天我们终于发现，其实我们就是被制造出来的具有自我繁衍功能机器人呢😄。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;首先，提到阿西莫夫老人家，最最出名也是不得不提的就是&lt;/p&gt;
&lt;p&gt;机器人学三大定律&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;机器人不得伤害人类，或因不作为而使人类受到伤害。
除非违背第一法则，机器人必须服从人类的命令。
在不违背第一及第二法则的情况下，机器人必须保护自己。&lt;/cod</summary>
      
    
    
    
    <category term="林中笔记" scheme="http://kinoandworld.github.io/categories/%E6%9E%97%E4%B8%AD%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="书评" scheme="http://kinoandworld.github.io/tags/%E4%B9%A6%E8%AF%84/"/>
    
  </entry>
  
  <entry>
    <title>在UICollectionView上实现StickyHeader效果</title>
    <link href="http://kinoandworld.github.io/2016/05/20/2016-05-20-uicollectionview-sticky-header-implement-principle/"/>
    <id>http://kinoandworld.github.io/2016/05/20/2016-05-20-uicollectionview-sticky-header-implement-principle/</id>
    <published>2016-05-20T08:25:43.000Z</published>
    <updated>2025-10-28T09:01:11.517Z</updated>
    
    <content type="html"><![CDATA[<p>前几天在用UICollectionView实现组合式布局的时候，想到如果在CollectionView上要求sticky header（也就是header自动悬停置顶）的效果应当如何实现。<br>我们都知道如果是在UITableView上实现非常简单，只要设置style为group然后多个section，headerView就会自动吸附在顶部。而collectionView虽然功能强大得多，但是原生并没有支持直接设置这个效果，所以需要自己实现。</p><p>作为一个懒人，首先想到的自然是站在巨人的肩膀上，<a href="https://github.com/jamztang/CSStickyHeaderFlowLayout">CSStickyHeaderFlowLayout</a>是一个比较知名的CollectionView布局控件，它支持sticky header效果以及头部的视差滚动效果，效果很赞。但是感觉稍微重了些，需要做更多的设置以及修改基类等。</p><p>然后我又找到了一篇文章，虽然已经是3年前的文章，但是写得非常简明清晰，而且阅读完有豁然开朗的感觉。</p><p>文章很短，全文如下：<a href="http://blog.radi.ws/post/32905838158/sticky-headers-for-uicollectionview-using">http://blog.radi.ws/post/32905838158/sticky-headers-for-uicollectionview-using</a></p><p>核心原理就是三句话：</p><ul><li><code>The header should be positioned so it can never go further up than one header height above the first cell in the section.</code></li><li><code>The header should be positioned so it can never go further down than one header header height above the lower bounds of the last cell in the section.</code></li><li><code>The header should be positioned so it usually stays around the top edge, referencing the content offset of the collection view.</code></li></ul><p>代码也很简单，只需要在UICollectionViewFlowLayout实现<code>layoutAttributesForElementsInRect</code>和<code>shouldInvalidateLayoutForBoundsChange</code>两个方法。</p><p>接着我附上文中源代码以及自己写的注释，穿插了一些对文章初略的翻译。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSArray</span> *)layoutAttributesForElementsInRect:(<span class="built_in">CGRect</span>)rect &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  返回当前显示区域的所有布局信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">NSMutableArray</span> *answer = [[<span class="keyword">super</span> layoutAttributesForElementsInRect:rect] mutableCopy];</span><br><span class="line">    <span class="built_in">UICollectionView</span> * <span class="keyword">const</span> cv = <span class="keyword">self</span>.collectionView;</span><br><span class="line">    <span class="built_in">CGPoint</span> <span class="keyword">const</span> contentOffset = cv.contentOffset;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSMutableIndexSet</span> *missingSections = [<span class="built_in">NSMutableIndexSet</span> indexSet];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  找出所有UICollectionElementCategoryCell类型的cell</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">UICollectionViewLayoutAttributes</span> *layoutAttributes <span class="keyword">in</span> answer) &#123;</span><br><span class="line">        <span class="keyword">if</span> (layoutAttributes.representedElementCategory == <span class="built_in">UICollectionElementCategoryCell</span>) &#123;</span><br><span class="line">            [missingSections addIndex:layoutAttributes.indexPath.section];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  再从里面删除所有UICollectionElementKindSectionHeader类型的cell</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">UICollectionViewLayoutAttributes</span> *layoutAttributes <span class="keyword">in</span> answer) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([layoutAttributes.representedElementKind isEqualToString:<span class="built_in">UICollectionElementKindSectionHeader</span>]) &#123;</span><br><span class="line">            [missingSections removeIndex:layoutAttributes.indexPath.section];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  默认情况下，为missingSections手动插入attributes，应该是为rect外的section生成attributes</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    [missingSections enumerateIndexesUsingBlock:^(<span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSIndexPath</span> *indexPath = [<span class="built_in">NSIndexPath</span> indexPathForItem:<span class="number">0</span> inSection:idx];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">UICollectionViewLayoutAttributes</span> *layoutAttributes = [<span class="keyword">self</span> layoutAttributesForSupplementaryViewOfKind:<span class="built_in">UICollectionElementKindSectionHeader</span> atIndexPath:indexPath];</span><br><span class="line"></span><br><span class="line">        [answer addObject:layoutAttributes];</span><br><span class="line"></span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">UICollectionViewLayoutAttributes</span> *layoutAttributes <span class="keyword">in</span> answer) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *  从answer中储存的布局信息中，针对UICollectionElementKindSectionHeader...</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> ([layoutAttributes.representedElementKind isEqualToString:<span class="built_in">UICollectionElementKindSectionHeader</span>]) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">NSInteger</span> section = layoutAttributes.indexPath.section;</span><br><span class="line">            <span class="built_in">NSInteger</span> numberOfItemsInSection = [cv numberOfItemsInSection:section];</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             *  为什么需要firstCellIndexPath和lastCellIndexPath呢？</span></span><br><span class="line"><span class="comment">             *  header应当保持着距离本section第一个cell的最大距离，简单来说就是header在置顶之前要贴着cell</span></span><br><span class="line"><span class="comment">             *  同理，header应当保持着与最后一个cell的最小距离，</span></span><br><span class="line"><span class="comment">             *  最后，在不违反上面两则约束的前提下，通过collection view的offset与header的高度来使header处于 origin.y = 0 的状态。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="built_in">NSIndexPath</span> *firstCellIndexPath = [<span class="built_in">NSIndexPath</span> indexPathForItem:<span class="number">0</span> inSection:section];</span><br><span class="line">            <span class="built_in">NSIndexPath</span> *lastCellIndexPath = [<span class="built_in">NSIndexPath</span> indexPathForItem:MAX(<span class="number">0</span>, (numberOfItemsInSection - <span class="number">1</span>)) inSection:section];</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             *  针对当前layoutAttributes的section， 找出第一个和最后一个普通cell的位置</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="built_in">UICollectionViewLayoutAttributes</span> *firstCellAttrs = [<span class="keyword">self</span> layoutAttributesForItemAtIndexPath:firstCellIndexPath];</span><br><span class="line">            <span class="built_in">UICollectionViewLayoutAttributes</span> *lastCellAttrs = [<span class="keyword">self</span> layoutAttributesForItemAtIndexPath:lastCellIndexPath];</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             *  获取当前处理header的高度和位置，然后通过firstCellAttrs和lastCellAttrs确定header是否置顶</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="built_in">CGFloat</span> headerHeight = <span class="built_in">CGRectGetHeight</span>(layoutAttributes.frame);</span><br><span class="line">            <span class="built_in">CGPoint</span> origin = layoutAttributes.frame.origin;</span><br><span class="line">            origin.y = MIN(</span><br><span class="line">                           MAX(</span><br><span class="line">                               contentOffset.y,</span><br><span class="line">                               (<span class="built_in">CGRectGetMinY</span>(firstCellAttrs.frame) - headerHeight)</span><br><span class="line">                               ),</span><br><span class="line">                           (<span class="built_in">CGRectGetMaxY</span>(lastCellAttrs.frame) - headerHeight)</span><br><span class="line">                           );</span><br><span class="line"></span><br><span class="line">            layoutAttributes.zIndex = <span class="number">1024</span>;</span><br><span class="line">            layoutAttributes.frame = (<span class="built_in">CGRect</span>)&#123;</span><br><span class="line">                .origin = origin,</span><br><span class="line">                .size = layoutAttributes.frame.size</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>) shouldInvalidateLayoutForBoundsChange:(<span class="built_in">CGRect</span>)newBound &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>感觉又涨了姿势，撒花。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;前几天在用UICollectionView实现组合式布局的时候，想到如果在CollectionView上要求sticky header（也就是header自动悬停置顶）的效果应当如何实现。&lt;br&gt;我们都知道如果是在UITableView上实现非常简单，只要设置style为g</summary>
      
    
    
    
    <category term="iOS" scheme="http://kinoandworld.github.io/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>Runtime实践之打造易复用的iOS公共页面</title>
    <link href="http://kinoandworld.github.io/2016/05/03/2016-05-03-build-a-reusable-common-page-in-ios/"/>
    <id>http://kinoandworld.github.io/2016/05/03/2016-05-03-build-a-reusable-common-page-in-ios/</id>
    <published>2016-05-03T10:04:23.000Z</published>
    <updated>2025-10-28T09:01:11.517Z</updated>
    
    <content type="html"><![CDATA[<p>相信我们开发的项目中，只要涉及到网络交互，都会遇到一个再普遍的不过的需求，那就是出于用户体验的需要，在请求开始的时候显示<code>加载页</code>，请求到空数据的时候显示<code>空内容页</code>，以及请求出错的时候显示的<code>错误或重试页</code>。这三类页面在一个项目中通常是一致的（至多会有图标和文案的变化），但却要求可能在每一个涉及网络请求的页面呈现。</p><p>##(；′⌒`)<br>如果没有大局观，一开始接到需求就开始在某ViewController里面添加几个View用来展现。</p><p>举个例子，如果要添加一个loading view，</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">UIView</span> *loadingView;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">UIImageView</span> *loadingImageView;</span><br></pre></td></tr></table></figure><p>然后增加方法，视图的初始化和配置就省略了</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  加载视图</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)startLoading&#123;</span><br><span class="line">    [<span class="keyword">self</span>.view addSubview:<span class="keyword">self</span>.loadingView];</span><br><span class="line">    [<span class="keyword">self</span>.loadingImageView startAnimating];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  停止加载并消失</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)stopLoading&#123;</span><br><span class="line">    [<span class="keyword">self</span>.loadingImageView stopAnimating];</span><br><span class="line">    [<span class="keyword">self</span>.loadingView removeFromSuperview];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OK，这样做实现上没问题，但是遇到下一个需要展示这些页面的ViewController，只能使用copy&amp;paste大法，把property和方法实现都搬到另一个ViewController，倘若有10个以上的页面，再加上万一需要修改页面的视图结构，你就会深刻的体会到</p><p><img src="https://upload-images.jianshu.io/upload_images/25038-62e32ccb70ef2db5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/220/format/webp" alt="img"></p><p>总所周知有个大原则叫做Don’t repeat yourself。再运用上我们不为什么就很熟练的面向对象思维，自然而然可以想到，使用继承大法。</p><p>##╮(╯_╰)╭</p><p>实现方法很简单</p><ul><li><p>首先创建一个BaseViewController，将几个property转移过来，并且展现方法也照搬，在.h文件暴露出来。</p></li><li><p>然后把所有用到的Controller都继承自BaseViewController，调用的地方可以保持不变，会自动调用父类的方法。</p></li></ul><p>但是这样做还是不够好，因为这需要我们把所有的Viewcontroller的头文件都改一遍，引入BaseViewController并集成，就是所谓这是带有<code>侵入性</code>的。更致命的是，如果你的ViewController本身集成了另外的BaseController，由于Objective-C不支持多继承，你只能去修改另一个BaseController……有点悲伤。</p><p>##╭(′▽`)╯</p><p>通过标题的剧透，我们知道最后的实现跟runtime有关，那么主角也该出场了。<br>其实就是使用Category + runtime的对象关联。在上面的方案中，解决集成BaseViewController的侵入性的方案就是使用category为UIViewController添加方法，但是category是不能直接使用property保存私有变量的，于是引入runtime的AssociatedObject系列方法，可以动态为对象添加成员变量，这几乎是runtime最基础的应用。</p><p>非常简单的，只用到两个方法，其实就是一个Setter和Getter</p><p><code>id objc_getAssociatedObject(id object, const void *key)</code></p><p><code>void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy)</code></p><p>如果想深入探究一下，有人已经写得挺全面了，可以点击<a href="http://blog.leichunfeng.com/blog/2015/06/26/objective-c-associated-objects-implementation-principle/">这篇文章</a></p><p>在本例中，用法大概是这样</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - Getter</span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">UIView</span> *)loadingView&#123;</span><br><span class="line">    <span class="built_in">UIView</span> *loadingView = objc_getAssociatedObject(<span class="keyword">self</span>, &amp;PresnterLoadingViewKey);</span><br><span class="line">    <span class="keyword">if</span> (!loadingView) &#123;</span><br><span class="line">        loadingView = [[<span class="built_in">UIView</span> alloc] initWithFrame:<span class="keyword">self</span>.view.bounds];</span><br><span class="line">        objc_setAssociatedObject(<span class="keyword">self</span>, &amp;PresnterLoadingViewKey, loadingView, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">        </span><br><span class="line">        loadingView.backgroundColor = [<span class="built_in">UIColor</span> whiteColor];</span><br><span class="line">        [loadingView addSubview:<span class="keyword">self</span>.loadingImageView];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> loadingView;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">UIImageView</span> *)loadingImageView&#123;</span><br><span class="line">    <span class="built_in">UIImageView</span> *imageView = objc_getAssociatedObject(<span class="keyword">self</span>, &amp;PresnterLoadingImageViewKey);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!imageView) &#123;</span><br><span class="line">        imageView = [[<span class="built_in">UIImageView</span> alloc] initWithFrame:</span><br><span class="line">                         <span class="built_in">CGRectMake</span>(<span class="keyword">self</span>.view.bounds.size.width / <span class="number">2</span> - <span class="number">100</span>, <span class="keyword">self</span>.view.bounds.size.height/<span class="number">2</span> - <span class="number">80</span>, <span class="number">200</span>, <span class="number">150</span>)];</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSMutableArray</span> *tmpArr = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">80</span>; i++) &#123;</span><br><span class="line">            <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageNamed:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;01-progress00%02d.jpg&quot;</span>,i]];</span><br><span class="line">            [tmpArr addObject:image];</span><br><span class="line">        &#125;</span><br><span class="line">        [imageView setAnimationImages:[<span class="built_in">NSArray</span> arrayWithArray:tmpArr]];</span><br><span class="line">        imageView.animationDuration = <span class="number">2.0</span>;</span><br><span class="line">        </span><br><span class="line">        objc_setAssociatedObject(<span class="keyword">self</span>, &amp;PresnterLoadingImageViewKey, imageView, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> imageView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把实例化放进Getter，这样实现方法可以同上保持不变</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  加载视图</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)startLoading&#123;</span><br><span class="line">    [<span class="keyword">self</span>.view addSubview:<span class="keyword">self</span>.loadingView];</span><br><span class="line">    [<span class="keyword">self</span>.loadingImageView startAnimating];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  停止加载并消失</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)stopLoading&#123;</span><br><span class="line">    [<span class="keyword">self</span>.loadingImageView stopAnimating];</span><br><span class="line">    [<span class="keyword">self</span>.loadingView removeFromSuperview];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后只需要在你需要用到这些页面的ViewController引入UIViewController+Presenter.h<br>然后展示就好</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span> startLoading]; <span class="comment">//加载完成后调用 [self stopLoading];</span></span><br></pre></td></tr></table></figure><p>具体的代码我写了个demo放在github上，地址在<a href="https://github.com/KinoAndWorld/RuntimePracticeDemo">这里</a>。</p><p>另外实现了空白视图和失败重试视图的功能，跟loading页大同小异。<br>如此一来，这些公共页面的展示逻辑基本被封装进了category中，而且当我们需要修改展示的页面时，也只需修改文件里面的实现，然后暴露出方法，简单高效。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;相信我们开发的项目中，只要涉及到网络交互，都会遇到一个再普遍的不过的需求，那就是出于用户体验的需要，在请求开始的时候显示&lt;code&gt;加载页&lt;/code&gt;，请求到空数据的时候显示&lt;code&gt;空内容页&lt;/code&gt;，以及请求出错的时候显示的&lt;code&gt;错误或重试页&lt;/code&gt;</summary>
      
    
    
    
    <category term="iOS" scheme="http://kinoandworld.github.io/categories/iOS/"/>
    
    
  </entry>
  
</feed>
