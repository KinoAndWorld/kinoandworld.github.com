<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS | Kinoの技术博客]]></title>
  <link href="http://KinoAndWorld.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://KinoAndWorld.github.io/"/>
  <updated>2016-05-20T17:39:27+08:00</updated>
  <id>http://KinoAndWorld.github.io/</id>
  <author>
    <name><![CDATA[Kino]]></name>
    <email><![CDATA[kinoandworld@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[在UICollectionView上实现StickyHeader效果]]></title>
    <link href="http://KinoAndWorld.github.io/blog/2016/05/20/uicollectionview-sticky-header-implement-principle/"/>
    <updated>2016-05-20T16:25:43+08:00</updated>
    <id>http://KinoAndWorld.github.io/blog/2016/05/20/uicollectionview-sticky-header-implement-principle</id>
    <content type="html"><![CDATA[<p>前几天在用UICollectionView实现组合式布局的时候，想到如果在CollectionView上要求sticky header（也就是header自动悬停置顶）的效果应当如何实现。
我们都知道如果是在UITableView上实现非常简单，只要设置style为group然后多个section，headerView就会自动吸附在顶部。而collectionView虽然功能强大得多，但是原生并没有支持直接设置这个效果，所以需要自己实现。</p>

<p>作为一个懒人，首先想到的自然是站在巨人的肩膀上，<a href="https://github.com/jamztang/CSStickyHeaderFlowLayout">CSStickyHeaderFlowLayout</a>是一个比较知名的CollectionView布局控件，它支持sticky header效果以及头部的视差滚动效果，效果很赞。但是感觉稍微重了些，需要做更多的设置以及修改基类等。</p>

<p>然后我又找到了一篇文章，虽然已经是3年前的文章，但是写得非常简明清晰，而且阅读完有豁然开朗的感觉。</p>

<p>文章很短，全文如下：<a href="http://blog.radi.ws/post/32905838158/sticky-headers-for-uicollectionview-using">http://blog.radi.ws/post/32905838158/sticky-headers-for-uicollectionview-using</a></p>

<p>核心原理就是三句话：</p>

<ul>
<li><code>The header should be positioned so it can never go further up than one header height above the first cell in the section.</code></li>
<li><code>The header should be positioned so it can never go further down than one header header height above the lower bounds of the last cell in the section.</code></li>
<li><code>The header should be positioned so it usually stays around the top edge, referencing the content offset of the collection view.</code></li>
</ul>


<p>代码也很简单，只需要在UICollectionViewFlowLayout实现<code>layoutAttributesForElementsInRect</code>和<code>shouldInvalidateLayoutForBoundsChange</code>两个方法。</p>

<p>接着我附上文中源代码以及自己写的注释，穿插了一些对文章初略的翻译。</p>

<p>```objc
&ndash; (NSArray *)layoutAttributesForElementsInRect:(CGRect)rect {</p>

<pre><code>/**
 *  返回当前显示区域的所有布局信息
 */
NSMutableArray *answer = [[super layoutAttributesForElementsInRect:rect] mutableCopy];
UICollectionView * const cv = self.collectionView;
CGPoint const contentOffset = cv.contentOffset;

NSMutableIndexSet *missingSections = [NSMutableIndexSet indexSet];

/**
 *  找出所有UICollectionElementCategoryCell类型的cell
 */
for (UICollectionViewLayoutAttributes *layoutAttributes in answer) {
    if (layoutAttributes.representedElementCategory == UICollectionElementCategoryCell) {
        [missingSections addIndex:layoutAttributes.indexPath.section];
    }
}
/**
 *  再从里面删除所有UICollectionElementKindSectionHeader类型的cell
 */
for (UICollectionViewLayoutAttributes *layoutAttributes in answer) {
    if ([layoutAttributes.representedElementKind isEqualToString:UICollectionElementKindSectionHeader]) {
        [missingSections removeIndex:layoutAttributes.indexPath.section];
    }
}

/**
 *  默认情况下，为missingSections手动插入attributes，应该是为rect外的section生成attributes
 */
[missingSections enumerateIndexesUsingBlock:^(NSUInteger idx, BOOL *stop) {

    NSIndexPath *indexPath = [NSIndexPath indexPathForItem:0 inSection:idx];

    UICollectionViewLayoutAttributes *layoutAttributes = [self layoutAttributesForSupplementaryViewOfKind:UICollectionElementKindSectionHeader atIndexPath:indexPath];

    [answer addObject:layoutAttributes];

}];


for (UICollectionViewLayoutAttributes *layoutAttributes in answer) {

    /**
     *  从answer中储存的布局信息中，针对UICollectionElementKindSectionHeader...
     */
    if ([layoutAttributes.representedElementKind isEqualToString:UICollectionElementKindSectionHeader]) {

        NSInteger section = layoutAttributes.indexPath.section;
        NSInteger numberOfItemsInSection = [cv numberOfItemsInSection:section];

        /**
         *  为什么需要firstCellIndexPath和lastCellIndexPath呢？
         *  header应当保持着距离本section第一个cell的最大距离，简单来说就是header在置顶之前要贴着cell
         *  同理，header应当保持着与最后一个cell的最小距离，
         *  最后，在不违反上面两则约束的前提下，通过collection view的offset与header的高度来使header处于 origin.y = 0 的状态。
         */
        NSIndexPath *firstCellIndexPath = [NSIndexPath indexPathForItem:0 inSection:section];
        NSIndexPath *lastCellIndexPath = [NSIndexPath indexPathForItem:MAX(0, (numberOfItemsInSection - 1)) inSection:section];

        /**
         *  针对当前layoutAttributes的section， 找出第一个和最后一个普通cell的位置
         */
        UICollectionViewLayoutAttributes *firstCellAttrs = [self layoutAttributesForItemAtIndexPath:firstCellIndexPath];
        UICollectionViewLayoutAttributes *lastCellAttrs = [self layoutAttributesForItemAtIndexPath:lastCellIndexPath];

        /**
         *  获取当前处理header的高度和位置，然后通过firstCellAttrs和lastCellAttrs确定header是否置顶
         */
        CGFloat headerHeight = CGRectGetHeight(layoutAttributes.frame);
        CGPoint origin = layoutAttributes.frame.origin;
        origin.y = MIN(
                       MAX(
                           contentOffset.y,
                           (CGRectGetMinY(firstCellAttrs.frame) - headerHeight)
                           ),
                       (CGRectGetMaxY(lastCellAttrs.frame) - headerHeight)
                       );

        layoutAttributes.zIndex = 1024;
        layoutAttributes.frame = (CGRect){
            .origin = origin,
            .size = layoutAttributes.frame.size
        };
    }
}
return answer;
</code></pre>

<p>}</p>

<ul>
<li>(BOOL) shouldInvalidateLayoutForBoundsChange:(CGRect)newBound {
  return YES;
}
```</li>
</ul>


<p>感觉又涨了姿势，撒花。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Runtime实践之打造易复用的iOS公共页面]]></title>
    <link href="http://KinoAndWorld.github.io/blog/2016/05/03/build-a-reusable-common-page-in-ios/"/>
    <updated>2016-05-03T18:04:23+08:00</updated>
    <id>http://KinoAndWorld.github.io/blog/2016/05/03/build-a-reusable-common-page-in-ios</id>
    <content type="html"><![CDATA[<p>相信我们开发的项目中，只要涉及到网络交互，都会遇到一个再普遍的不过的需求，那就是出于用户体验的需要，在请求开始的时候显示<code>加载页</code>，请求到空数据的时候显示<code>空内容页</code>，以及请求出错的时候显示的<code>错误或重试页</code>。这三类页面在一个项目中通常是一致的（至多会有图标和文案的变化），但却要求可能在每一个涉及网络请求的页面呈现。</p>

<h2>(；′⌒`)</h2>

<p>如果没有大局观，一开始接到需求就开始在某ViewController里面添加几个View用来展现。</p>

<p>举个例子，如果要添加一个loading view，</p>

<p><code>objc
@property (strong, nonatomic) UIView *loadingView;
@property (strong, nonatomic) UIImageView *loadingImageView;
</code>
然后增加方法，视图的初始化和配置就省略了
```objc
/<em>*
 *  加载视图
 </em>/
&ndash; (void)startLoading{</p>

<pre><code>[self.view addSubview:self.loadingView];
[self.loadingImageView startAnimating];
</code></pre>

<p>}</p>

<p>/<em>*
 *  停止加载并消失
 </em>/
&ndash; (void)stopLoading{</p>

<pre><code>[self.loadingImageView stopAnimating];
[self.loadingView removeFromSuperview];
</code></pre>

<p>}
```</p>

<p>OK，这样做实现上没问题，但是遇到下一个需要展示这些页面的ViewController，只能使用copy&amp;paste大法，把property和方法实现都搬到另一个ViewController，倘若有10个以上的页面，再加上万一需要修改页面的视图结构，你就会深刻的体会到
<img src="/images/heart-tried.jpg"></p>

<p>总所周知有个大原则叫做Don&rsquo;t repeat yourself。再运用上我们不为什么就很熟练的面向对象思维，自然而然可以想到，使用继承大法。</p>

<h2>╮(╯_╰)╭</h2>

<p>实现方法很简单</p>

<ul>
<li><p>首先创建一个BaseViewController，将几个property转移过来，并且展现方法也照搬，在.h文件暴露出来。</p></li>
<li><p>然后把所有用到的Controller都继承自BaseViewController，调用的地方可以保持不变，会自动调用父类的方法。</p></li>
</ul>


<p>但是这样做还是不够好，因为这需要我们把所有的Viewcontroller的头文件都改一遍，引入BaseViewController并集成，就是所谓这是带有<code>侵入性</code>的。更致命的是，如果你的ViewController本身集成了另外的BaseController，由于Objective-C不支持多继承，你只能去修改另一个BaseController……有点悲伤。</p>

<h2>╭(′▽`)╯</h2>

<p>通过标题的剧透，我们知道最后的实现跟runtime有关，那么主角也该出场了。
其实就是使用Category + runtime的对象关联。在上面的方案中，解决集成BaseViewController的侵入性的方案就是使用category为UIViewController添加方法，但是category是不能直接使用property保存私有变量的，于是引入runtime的AssociatedObject系列方法，可以动态为对象添加成员变量，这几乎是runtime最基础的应用。</p>

<p>非常简单的，只用到两个方法，其实就是一个Setter和Getter</p>

<p><code>id objc_getAssociatedObject(id object, const void *key)</code></p>

<p><code>void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy)</code></p>

<p>如果想深入探究一下，有人已经写得挺全面了，可以点击<a href="http://blog.leichunfeng.com/blog/2015/06/26/objective-c-associated-objects-implementation-principle/">这篇文章</a></p>

<p>在本例中，用法大概是这样</p>

<p>```objc</p>

<h1>pragma mark &ndash; Getter</h1>

<ul>
<li><p>(UIView <em>)loadingView{
  UIView </em>loadingView = objc_getAssociatedObject(self, &amp;PresnterLoadingViewKey);
  if (!loadingView) {
      loadingView = [[UIView alloc] initWithFrame:self.view.bounds];
      objc_setAssociatedObject(self, &amp;PresnterLoadingViewKey, loadingView, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</p>

<pre><code>  loadingView.backgroundColor = [UIColor whiteColor];
  [loadingView addSubview:self.loadingImageView];
</code></pre>

<p>  }
  return loadingView;
}</p></li>
<li><p>(UIImageView <em>)loadingImageView{
  UIImageView </em>imageView = objc_getAssociatedObject(self, &amp;PresnterLoadingImageViewKey);</p>

<p>  if (!imageView) {
      imageView = [[UIImageView alloc] initWithFrame:
                       CGRectMake(self.view.bounds.size.width / 2 &ndash; 100, self.view.bounds.size.height/2 &ndash; 80, 200, 150)];</p>

<pre><code>  NSMutableArray *tmpArr = [NSMutableArray array];
  for (int i = 0; i &lt;= 80; i++) {
      UIImage *image = [UIImage imageNamed:[NSString stringWithFormat:@"01-progress00%02d.jpg",i]];
      [tmpArr addObject:image];
  }
  [imageView setAnimationImages:[NSArray arrayWithArray:tmpArr]];
  imageView.animationDuration = 2.0;

  objc_setAssociatedObject(self, &amp;PresnterLoadingImageViewKey, imageView, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
</code></pre>

<p>  }</p>

<p>  return imageView;
}
```</p></li>
</ul>


<p>把实例化放进Getter，这样实现方法可以同上保持不变</p>

<p>```objc
/<em>*
 *  加载视图
 </em>/
&ndash; (void)startLoading{</p>

<pre><code>[self.view addSubview:self.loadingView];
[self.loadingImageView startAnimating];
</code></pre>

<p>}</p>

<p>/<em>*
 *  停止加载并消失
 </em>/
&ndash; (void)stopLoading{</p>

<pre><code>[self.loadingImageView stopAnimating];
[self.loadingView removeFromSuperview];
</code></pre>

<p>}
```</p>

<p>最后只需要在你需要用到这些页面的ViewController引入UIViewController+Presenter.h
然后展示就好
<code>objc
[self startLoading]; //加载完成后调用 [self stopLoading];
</code></p>

<p>具体的代码我写了个demo放在github上，地址在<a href="https://github.com/KinoAndWorld/RuntimePracticeDemo">这里</a>。</p>

<p>另外实现了空白视图和失败重试视图的功能，跟loading页大同小异。
如此一来，这些公共页面的展示逻辑基本被封装进了category中，而且当我们需要修改展示的页面时，也只需修改文件里面的实现，然后暴露出方法，简单高效。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[打造一个直观易复用的iOS设置菜单页]]></title>
    <link href="http://KinoAndWorld.github.io/blog/2016/04/05/build-a-reusable-menu-setting-item-in-ios/"/>
    <updated>2016-04-05T16:09:14+08:00</updated>
    <id>http://KinoAndWorld.github.io/blog/2016/04/05/build-a-reusable-menu-setting-item-in-ios</id>
    <content type="html"><![CDATA[<p>几乎每一个App都有一个设置菜单页，而且他们几乎都长这样：</p>

<p><img src="/images/setting-page-shot.jpg"></p>

<h2>反面教材</h2>

<p>最简单最原始的做法是这样的：</p>

<p>```objc
&ndash; (UITableViewCell <em>)tableView:(UITableView </em>)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath{</p>

<pre><code>UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@"cell"
                                                        forIndexPath:indexPath];

switch (indexPath.row) {
    case 0:
        // configure cell
        break;
    case 1:
        // configure cell
        break;
    case 2:
        // configure cell
        break;
}
return cell;
</code></pre>

<p>}</p>

<ul>
<li><p>(void)tableView:(UITableView <em>)tableView didSelectRowAtIndexPath:(NSIndexPath </em>)indexPath{
  [tableView deselectRowAtIndexPath:indexPath animated:YES];</p>

<p>  switch (indexPath.row) {
      case 0:
          // click cell 0
          break;
      case 1:
          // click cell 1
          break;
      case 2:
          // click cell 2
          break;
  }
}
```</p></li>
</ul>


<p>这样做不仅违反了DRY原则，在菜单项比较多的情况下烦不胜烦，而且一旦需要修改某个菜单项的内容，或者插入或者删除，修改起来都是非常容易出错的，换句话说，可维护性非常差。</p>

<h2>抽象、依赖转移</h2>

<p>通过观察我们可以发现，这些列表的结构非常相似，那么很自然地我们可以想到建立一个通用的模型来表示一个菜单.</p>

<p>```objc KOSettingItem.h</p>

<p>@interface KOSettingItem : NSObject</p>

<p>@property (copy, nonatomic) NSString <em>title;
@property (strong, nonatomic) UIImage </em>imageIcon;
@property (assign, nonatomic) UITableViewCellAccessoryType accessoryType;
@property (copy, nonatomic) void(^handleCallback)();</p>

<ul>
<li><p>(instancetype) itemWithTitle:(NSString <em>)title
                        icon:(UIImage </em>)image;</p></li>
<li><p>(instancetype) itemWithTitle:(NSString <em>)title
                        icon:(UIImage </em>)image
                       block:(void(^)())handle;</p></li>
<li><p>(id)initWithTitle:(NSString <em>)title
             icon:(UIImage </em>)image
            block:(void(^)())handle;</p></li>
</ul>


<p>@end  <br/>
```</p>

<p>```objc KOSettingItem.m</p>

<pre><code>@implementation KOSettingItem

+ (instancetype) itemWithTitle:(NSString *)title
                          icon:(UIImage *)image{
    return [[self alloc] itemWithTitle:title icon:image];
}

+ (instancetype) itemWithTitle:(NSString *)title
                          icon:(UIImage *)image
                          block:(void(^)())handle{
    KOSettingItem *item = [[self alloc] initWithTitle:title icon:image block:handle];
    return item;
}

- (id)initWithTitle:(NSString *)title
               icon:(UIImage *)image
              block:(void(^)())handle{
    if (self = [super init]) {
        self.title = title;
        self.imageIcon = image;
        self.handleCallback = handle;
        self.accessoryType = UITableViewCellAccessoryDisclosureIndicator;
    }
    return self;
}

@end
</code></pre>

<p>```</p>

<p>一个简单的模型就这样建好了，其中我们用block写了一个handleCallback用来处理表格的点击事件，接着我们来应用到TableView中，首先新增一个property <code>@property (strong, nonatomic) NSArray *settingItems;</code></p>

<p>然后在ViewDidLoad中</p>

<p>```objc</p>

<pre><code>KOSettingItem *item1 = [KOSettingItem itemWithTitle:@"菜单1" icon:[UIImage imageNamed:@"Carrot"]];
[item1 setHandleCallback:^{
    NSLog(@"点击菜单1");
}];

KOSettingItem *item2 = [KOSettingItem itemWithTitle:@"菜单2" icon:[UIImage imageNamed:@"Owl"]];
[item1 setHandleCallback:^{
    NSLog(@"点击菜单2");
}];

KOSettingItem *item3 = [KOSettingItem itemWithTitle:@"菜单3" icon:[UIImage imageNamed:@"Rubber-Duck"]];
[item1 setHandleCallback:^{
    NSLog(@"点击菜单3");
}];

KOSettingItem *item4 = [KOSettingItem itemWithTitle:@"菜单4" icon:[UIImage imageNamed:@"Snowman"]];
[item1 setHandleCallback:^{
    NSLog(@"点击菜单4");
}];

self.settingItems = @[item1, item2, item3, item4];
</code></pre>

<p>```</p>

<p>最后修改一下TableView的Datasource和Delegate</p>

<p>```objc</p>

<pre><code>- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section{
    return self.settingItems.count;
}

- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath{
    return 44;
}

- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath{

    UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@"cell"
                                                            forIndexPath:indexPath];

    KOSettingItem *item = self.settingItems[indexPath.row];
    cell.textLabel.text = item.title;
    cell.imageView.image = item.imageIcon;
    cell.accessoryType = item.accessoryType;

    return cell;
}

- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath{
    [tableView deselectRowAtIndexPath:indexPath animated:YES];

    KOSettingItem *item = self.settingItems[indexPath.row];
    if (item.handleCallback) {
        item.handleCallback();
    }
}
</code></pre>

<p>```</p>

<p>我们发现再也不需要冗长的switch语句，如果需要增删菜单项，只需要修改settingItems里面的item顺序，并且由于点击事件绑定到KOSettingItem里面，也不需要担心事件与item不对应的情况，除非有特殊的样式需求，我们可以几乎不用再更改UITableViewDataSource与UITableViewDelegate的实现。</p>

<h2>尾声</h2>

<p>文章只是提供了一个思路，而且出于简明的目的KOSettingItem的模型非常简单，实际上你可以通过添加变量达到更多的可定制化效果，比如分割线的offset，自定义的accessoryView等等，完整的demo可以戳<a href="https://github.com/KinoAndWorld/MenuSettingViewDemo">这里</a>。</p>

<p>运行一下，最后的结果如图，虽然还是平淡无奇 ：）</p>

<p><img src="/images/setting-page-finish.png"></p>

<p>最后吐槽一下自己，真的好久没写博客了<em>(:з」∠)</em></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS测试流程简化：通过脚本导出ipa包与上传到Fir]]></title>
    <link href="http://KinoAndWorld.github.io/blog/2015/06/16/ios-archive-and-post-to-fir-script/"/>
    <updated>2015-06-16T14:01:47+08:00</updated>
    <id>http://KinoAndWorld.github.io/blog/2015/06/16/ios-archive-and-post-to-fir-script</id>
    <content type="html"><![CDATA[<h3>前言</h3>

<p>在我们当前的开发流程中，大致分为 <strong>开发-测试-修复Bugs-测试反馈</strong> 这样的循环中，特别是在功能需求频繁修改和UI细节不断调整的节奏中，我们通常需要不停地在Xcode上build-选择profile-archive，然后等待几分钟，导出ipa的包，然后再把包上传到一个版本仓库中，这个仓库或许是自己搭建的服务器，或许是TestFlight、Fir等更专业的内测版本平台，总之通常都需要几个步骤才能全部完成。倘若一日之内需要上传3到4个包，对工作效率的影响尚且不谈，重复同样的事情本身心情就不舒畅。</p>

<h3>祭出利器</h3>

<p>要如何做到把上述的N个步骤简化成一步呢，其实很简单。拿Fir为例，Fir提供了可供调用的app上传接口（其他平台我暂时不知道，如果是自己搭建的服务器肯定可以提供上传接口），而且还有好心人把接口写成了脚本（参考资源1），非常nice。但是这样的话还是要自己导出ipa，还是有些繁琐，于是我又找了些许资料，熟悉了<code>xcodebuild</code>的用法，还顺带找到了别人写好的另一个脚本（参考资源2），剩下的事情就非常简单了，我合并了二者的脚本，做了一些代码修改，详细的代码可以戳<a href="https://gist.github.com/ec0d8072d3389a9f3b02.git">这里</a></p>

<p>这里边有些参数要修改成自己的项目，譬如</p>

<ul>
<li>workspace name</li>
<li>provisioningProfile</li>
<li>scheme name</li>
<li>还有Fir需要的AppID和UserToken</li>
</ul>


<p>配置好之后，把这个脚本放在xcworkspace同级目录，然后终端运行 <code>./archive_to_upload_fir.sh</code>
这时候你可以去喝杯咖啡奶茶美年达或者来一套广播体操，在一片宁静中完成了所有繁琐。</p>

<h3>缺点与改进</h3>

<p>当然我相信这并不是最终的解决方案，因为脚本还是存在着输出信息不够友好，如果出现编译错误还是要自己另外调试等不便，而且脚本本身还存在可以优化的地方，例如一些变量的参数化，让它变得更通用一些。</p>

<hr />

<p>参考资源：</p>

<ul>
<li><p><a href="https://gist.github.com/ggshily/8594b69a266a410d82a0">https://gist.github.com/ggshily/8594b69a266a410d82a0</a></p></li>
<li><p><a href="http://blog.csdn.net/vieri_ch/article/details/45147027">http://blog.csdn.net/vieri_ch/article/details/45147027</a></p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS开发中一些常量数值]]></title>
    <link href="http://KinoAndWorld.github.io/blog/2015/03/18/ios-const-value/"/>
    <updated>2015-03-18T14:41:02+08:00</updated>
    <id>http://KinoAndWorld.github.io/blog/2015/03/18/ios-const-value</id>
    <content type="html"><![CDATA[<h3>先说CGFloat</h3>

<p><em>几乎众所周知CGFloat其实是float和double的大一统，32位与64位浮点的联姻</em></p>

<p>那么具体有什么不同？先来看看  CGFloat的一些常量，</p>

<pre><code>CGFLOAT_TYPE
CGFLOAT_MAX
CGFLOAT_MIN
CGFLOAT_DEFINED
CGFLOAT_IS_DOUBLE
</code></pre>

<p>好奇心使然，看了下源码</p>

<p><code>``objc
/* Definition of</code>CGFLOAT_TYPE', <code>CGFLOAT_IS_DOUBLE',</code>CGFLOAT_MIN', and
   `CGFLOAT_MAX'. */</p>

<h1>if defined(<strong>LP64</strong>) &amp;&amp; <strong>LP64</strong></h1>

<h1>define CGFLOAT_TYPE double</h1>

<h1>define CGFLOAT_IS_DOUBLE 1</h1>

<h1>define CGFLOAT_MIN DBL_MIN</h1>

<h1>define CGFLOAT_MAX DBL_MAX</h1>

<h1>else</h1>

<h1>define CGFLOAT_TYPE float</h1>

<h1>define CGFLOAT_IS_DOUBLE 0</h1>

<h1>define CGFLOAT_MIN FLT_MIN</h1>

<h1>define CGFLOAT_MAX FLT_MAX</h1>

<h1>endif</h1>

<p>/<em> Definition of the <code>CGFloat' type and</code>CGFLOAT_DEFINED'. </em>/</p>

<p>typedef CGFLOAT_TYPE CGFloat;</p>

<h1>define CGFLOAT_DEFINED 1</h1>

<p>```</p>

<p>然后很清晰地看到</p>

<pre><code>CGFLOAT_TYPE         64位下是double 否则float
CGFLOAT_MAX          64位下是double的max 否则float的max
CGFLOAT_MIN          64位下是double的min 否则float的min
CGFLOAT_DEFINED      就是1 为定义而定义，暂时不知道用来判断什么
CGFLOAT_IS_DOUBLE    64位下是1 否则0
</code></pre>

<p><em>(:з」∠)</em>我是不是很无聊</p>

<p>还有一个，当一个浮点型除以0的时候，有的语言会抛出异常，而oc会返回一个“非正常”的值+INF，我们可以用INFINITY常量判断。ex:(aFloat== INFINITY)</p>

<h3>NSInteger</h3>

<p>类似的， NSInteger也是囊括了int和long的大一统（还有NSUInteger，多个unsigned），定义跟上面的浮点型是一个模子的。
下面说说我踩过的一个坑。</p>

<p>在很久很久以前，我还是习惯用C语言的变量类型int，在5S出来以前大家相安无事，直到有一天一个bug袭击了我。</p>

<p>代码是这样的：</p>

<p>```</p>

<pre><code>NSArray *array = [NSArray array];
int foundIndex = [array indexOfObject:@""];
if (NSNotFound == foundIndex) {
    NSLog(@"not found,handle it");
}
</code></pre>

<p>```
为什么iPhone4s，5之流都没问题，到5s上就不对了呢。</p>

<p>刚准备烧柱香拜一拜的时候，我点开了NSNotFound的定义，发现它==NSIntegerMax，而NSIntegerMax==LONG_MAX。</p>

<p>64位下，foundIndex因为超过表示范围会被截断成-1，因此它!=NSNotFound。</p>

<p>类似的还有很多，我们应该多多jump到源码，即使只是头文件，也能发现关于Objective-C的一些底层细节。</p>
]]></content>
  </entry>
  
</feed>
