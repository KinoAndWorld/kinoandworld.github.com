<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS | 奇诺の世界]]></title>
  <link href="http://KinoAndWorld.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://KinoAndWorld.github.io/"/>
  <updated>2016-04-05T17:27:45+08:00</updated>
  <id>http://KinoAndWorld.github.io/</id>
  <author>
    <name><![CDATA[Kino]]></name>
    <email><![CDATA[kinoandworld@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[打造一个直观易复用的iOS设置菜单页]]></title>
    <link href="http://KinoAndWorld.github.io/blog/2016/04/05/build-a-reusable-menu-setting-item-in-ios/"/>
    <updated>2016-04-05T16:09:14+08:00</updated>
    <id>http://KinoAndWorld.github.io/blog/2016/04/05/build-a-reusable-menu-setting-item-in-ios</id>
    <content type="html"><![CDATA[<p>几乎每一个App都有一个设置菜单页，而且他们几乎都长这样：</p>

<p><img src="/images/setting-page-shot.jpg"></p>

<h2>反面教材</h2>

<p>最简单最原始的做法是这样的：</p>

<p>```objc
&ndash; (UITableViewCell <em>)tableView:(UITableView </em>)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath{</p>

<pre><code>UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@"cell"
                                                        forIndexPath:indexPath];

switch (indexPath.row) {
    case 0:
        // configure cell
        break;
    case 1:
        // configure cell
        break;
    case 2:
        // configure cell
        break;
}
return cell;
</code></pre>

<p>}</p>

<ul>
<li><p>(void)tableView:(UITableView <em>)tableView didSelectRowAtIndexPath:(NSIndexPath </em>)indexPath{
  [tableView deselectRowAtIndexPath:indexPath animated:YES];</p>

<p>  switch (indexPath.row) {
      case 0:
          // click cell 0
          break;
      case 1:
          // click cell 1
          break;
      case 2:
          // click cell 2
          break;
  }
}
```</p></li>
</ul>


<p>这样做不仅违反了DRY原则，在菜单项比较多的情况下烦不胜烦，而且一旦需要修改某个菜单项的内容，或者插入或者删除，修改起来都是非常容易出错的，换句话说，可维护性非常差。</p>

<h2>抽象、依赖转移</h2>

<p>通过观察我们可以发现，这些列表的结构非常相似，那么很自然地我们可以想到建立一个通用的模型来表示一个菜单.</p>

<p>```objc KOSettingItem.h</p>

<p>@interface KOSettingItem : NSObject</p>

<p>@property (copy, nonatomic) NSString <em>title;
@property (strong, nonatomic) UIImage </em>imageIcon;
@property (assign, nonatomic) UITableViewCellAccessoryType accessoryType;
@property (copy, nonatomic) void(^handleCallback)();</p>

<ul>
<li><p>(instancetype) itemWithTitle:(NSString <em>)title
                        icon:(UIImage </em>)image;</p></li>
<li><p>(instancetype) itemWithTitle:(NSString <em>)title
                        icon:(UIImage </em>)image
                       block:(void(^)())handle;</p></li>
<li><p>(id)initWithTitle:(NSString <em>)title
             icon:(UIImage </em>)image
            block:(void(^)())handle;</p></li>
</ul>


<p>@end  <br/>
```</p>

<p>```objc KOSettingItem.m</p>

<pre><code>@implementation KOSettingItem

+ (instancetype) itemWithTitle:(NSString *)title
                          icon:(UIImage *)image{
    return [[self alloc] itemWithTitle:title icon:image];
}

+ (instancetype) itemWithTitle:(NSString *)title
                          icon:(UIImage *)image
                          block:(void(^)())handle{
    KOSettingItem *item = [[self alloc] initWithTitle:title icon:image block:handle];
    return item;
}

- (id)initWithTitle:(NSString *)title
               icon:(UIImage *)image
              block:(void(^)())handle{
    if (self = [super init]) {
        self.title = title;
        self.imageIcon = image;
        self.handleCallback = handle;
        self.accessoryType = UITableViewCellAccessoryDisclosureIndicator;
    }
    return self;
}

@end
</code></pre>

<p>```</p>

<p>一个简单的模型就这样建好了，其中我们用block写了一个handleCallback用来处理表格的点击事件，接着我们来应用到TableView中，首先新增一个property <code>@property (strong, nonatomic) NSArray *settingItems;</code></p>

<p>然后在ViewDidLoad中</p>

<p>```objc</p>

<pre><code>KOSettingItem *item1 = [KOSettingItem itemWithTitle:@"菜单1" icon:[UIImage imageNamed:@"Carrot"]];
[item1 setHandleCallback:^{
    NSLog(@"点击菜单1");
}];

KOSettingItem *item2 = [KOSettingItem itemWithTitle:@"菜单2" icon:[UIImage imageNamed:@"Owl"]];
[item1 setHandleCallback:^{
    NSLog(@"点击菜单2");
}];

KOSettingItem *item3 = [KOSettingItem itemWithTitle:@"菜单3" icon:[UIImage imageNamed:@"Rubber-Duck"]];
[item1 setHandleCallback:^{
    NSLog(@"点击菜单3");
}];

KOSettingItem *item4 = [KOSettingItem itemWithTitle:@"菜单4" icon:[UIImage imageNamed:@"Snowman"]];
[item1 setHandleCallback:^{
    NSLog(@"点击菜单4");
}];

self.settingItems = @[item1, item2, item3, item4];
</code></pre>

<p>```</p>

<p>最后修改一下TableView的Datasource和Delegate</p>

<p>```objc</p>

<pre><code>- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section{
    return self.settingItems.count;
}

- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath{
    return 44;
}

- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath{

    UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@"cell"
                                                            forIndexPath:indexPath];

    KOSettingItem *item = self.settingItems[indexPath.row];
    cell.textLabel.text = item.title;
    cell.imageView.image = item.imageIcon;
    cell.accessoryType = item.accessoryType;

    return cell;
}

- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath{
    [tableView deselectRowAtIndexPath:indexPath animated:YES];

    KOSettingItem *item = self.settingItems[indexPath.row];
    if (item.handleCallback) {
        item.handleCallback();
    }
}
</code></pre>

<p>```</p>

<p>我们发现再也不需要冗长的switch语句，如果需要增删菜单项，只需要修改settingItems里面的item顺序，并且由于点击事件绑定到KOSettingItem里面，也不需要担心事件与item不对应的情况，除非有特殊的样式需求，我们可以几乎不用再更改UITableViewDataSource与UITableViewDelegate的实现。</p>

<h2>尾声</h2>

<p>文章只是提供了一个思路，而且出于简明的目的KOSettingItem的模型非常简单，实际上你可以通过添加变量达到更多的可定制化效果，比如分割线的offset，自定义的accessoryView等等，完整的demo可以戳<a href="https://github.com/KinoAndWorld/MenuSettingViewDemo">这里</a>。</p>

<p>运行一下，最后的结果如图，虽然还是平淡无奇 ：）</p>

<p><img src="/images/setting-page-finish.png"></p>

<p>最后吐槽一下自己，真的好久没写博客了<em>(:з」∠)</em></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS测试流程简化：通过脚本导出ipa包与上传到Fir]]></title>
    <link href="http://KinoAndWorld.github.io/blog/2015/06/16/ios-archive-and-post-to-fir-script/"/>
    <updated>2015-06-16T14:01:47+08:00</updated>
    <id>http://KinoAndWorld.github.io/blog/2015/06/16/ios-archive-and-post-to-fir-script</id>
    <content type="html"><![CDATA[<h3>前言</h3>

<p>在我们当前的开发流程中，大致分为 <strong>开发-测试-修复Bugs-测试反馈</strong> 这样的循环中，特别是在功能需求频繁修改和UI细节不断调整的节奏中，我们通常需要不停地在Xcode上build-选择profile-archive，然后等待几分钟，导出ipa的包，然后再把包上传到一个版本仓库中，这个仓库或许是自己搭建的服务器，或许是TestFlight、Fir等更专业的内测版本平台，总之通常都需要几个步骤才能全部完成。倘若一日之内需要上传3到4个包，对工作效率的影响尚且不谈，重复同样的事情本身心情就不舒畅。</p>

<h3>祭出利器</h3>

<p>要如何做到把上述的N个步骤简化成一步呢，其实很简单。拿Fir为例，Fir提供了可供调用的app上传接口（其他平台我暂时不知道，如果是自己搭建的服务器肯定可以提供上传接口），而且还有好心人把接口写成了脚本（参考资源1），非常nice。但是这样的话还是要自己导出ipa，还是有些繁琐，于是我又找了些许资料，熟悉了<code>xcodebuild</code>的用法，还顺带找到了别人写好的另一个脚本（参考资源2），剩下的事情就非常简单了，我合并了二者的脚本，做了一些代码修改，详细的代码可以戳<a href="https://gist.github.com/ec0d8072d3389a9f3b02.git">这里</a></p>

<p>这里边有些参数要修改成自己的项目，譬如</p>

<ul>
<li>workspace name</li>
<li>provisioningProfile</li>
<li>scheme name</li>
<li>还有Fir需要的AppID和UserToken</li>
</ul>


<p>配置好之后，把这个脚本放在xcworkspace同级目录，然后终端运行 <code>./archive_to_upload_fir.sh</code>
这时候你可以去喝杯咖啡奶茶美年达或者来一套广播体操，在一片宁静中完成了所有繁琐。</p>

<h3>缺点与改进</h3>

<p>当然我相信这并不是最终的解决方案，因为脚本还是存在着输出信息不够友好，如果出现编译错误还是要自己另外调试等不便，而且脚本本身还存在可以优化的地方，例如一些变量的参数化，让它变得更通用一些。</p>

<hr />

<p>参考资源：</p>

<ul>
<li><p><a href="https://gist.github.com/ggshily/8594b69a266a410d82a0">https://gist.github.com/ggshily/8594b69a266a410d82a0</a></p></li>
<li><p><a href="http://blog.csdn.net/vieri_ch/article/details/45147027">http://blog.csdn.net/vieri_ch/article/details/45147027</a></p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS开发中一些常量数值]]></title>
    <link href="http://KinoAndWorld.github.io/blog/2015/03/18/ios-const-value/"/>
    <updated>2015-03-18T14:41:02+08:00</updated>
    <id>http://KinoAndWorld.github.io/blog/2015/03/18/ios-const-value</id>
    <content type="html"><![CDATA[<h3>先说CGFloat</h3>

<p><em>几乎众所周知CGFloat其实是float和double的大一统，32位与64位浮点的联姻</em></p>

<p>那么具体有什么不同？先来看看  CGFloat的一些常量，</p>

<pre><code>CGFLOAT_TYPE
CGFLOAT_MAX
CGFLOAT_MIN
CGFLOAT_DEFINED
CGFLOAT_IS_DOUBLE
</code></pre>

<p>好奇心使然，看了下源码</p>

<p><code>``objc
/* Definition of</code>CGFLOAT_TYPE', <code>CGFLOAT_IS_DOUBLE',</code>CGFLOAT_MIN', and
   `CGFLOAT_MAX'. */</p>

<h1>if defined(<strong>LP64</strong>) &amp;&amp; <strong>LP64</strong></h1>

<h1>define CGFLOAT_TYPE double</h1>

<h1>define CGFLOAT_IS_DOUBLE 1</h1>

<h1>define CGFLOAT_MIN DBL_MIN</h1>

<h1>define CGFLOAT_MAX DBL_MAX</h1>

<h1>else</h1>

<h1>define CGFLOAT_TYPE float</h1>

<h1>define CGFLOAT_IS_DOUBLE 0</h1>

<h1>define CGFLOAT_MIN FLT_MIN</h1>

<h1>define CGFLOAT_MAX FLT_MAX</h1>

<h1>endif</h1>

<p>/<em> Definition of the <code>CGFloat' type and</code>CGFLOAT_DEFINED'. </em>/</p>

<p>typedef CGFLOAT_TYPE CGFloat;</p>

<h1>define CGFLOAT_DEFINED 1</h1>

<p>```</p>

<p>然后很清晰地看到</p>

<pre><code>CGFLOAT_TYPE         64位下是double 否则float
CGFLOAT_MAX          64位下是double的max 否则float的max
CGFLOAT_MIN          64位下是double的min 否则float的min
CGFLOAT_DEFINED      就是1 为定义而定义，暂时不知道用来判断什么
CGFLOAT_IS_DOUBLE    64位下是1 否则0
</code></pre>

<p><em>(:з」∠)</em>我是不是很无聊</p>

<p>还有一个，当一个浮点型除以0的时候，有的语言会抛出异常，而oc会返回一个“非正常”的值+INF，我们可以用INFINITY常量判断。ex:(aFloat== INFINITY)</p>

<h3>NSInteger</h3>

<p>类似的， NSInteger也是囊括了int和long的大一统（还有NSUInteger，多个unsigned），定义跟上面的浮点型是一个模子的。
下面说说我踩过的一个坑。</p>

<p>在很久很久以前，我还是习惯用C语言的变量类型int，在5S出来以前大家相安无事，直到有一天一个bug袭击了我。</p>

<p>代码是这样的：</p>

<p>```</p>

<pre><code>NSArray *array = [NSArray array];
int foundIndex = [array indexOfObject:@""];
if (NSNotFound == foundIndex) {
    NSLog(@"not found,handle it");
}
</code></pre>

<p>```
为什么iPhone4s，5之流都没问题，到5s上就不对了呢。</p>

<p>刚准备烧柱香拜一拜的时候，我点开了NSNotFound的定义，发现它==NSIntegerMax，而NSIntegerMax==LONG_MAX。</p>

<p>64位下，foundIndex因为超过表示范围会被截断成-1，因此它!=NSNotFound。</p>

<p>类似的还有很多，我们应该多多jump到源码，即使只是头文件，也能发现关于Objective-C的一些底层细节。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[微信支付的小坑]]></title>
    <link href="http://KinoAndWorld.github.io/blog/2014/09/17/weixinpayforios/"/>
    <updated>2014-09-17T00:08:59+08:00</updated>
    <id>http://KinoAndWorld.github.io/blog/2014/09/17/weixinpayforios</id>
    <content type="html"><![CDATA[<h2>先说点题外话</h2>

<p>貌似很久很久没更新博客，有半年了吧，这半年忙着毕业的各种事情，忙着小或者比较大的项目，感受着初入职场的艰辛与喜悦，以及过着平淡无奇的小日子————好吧虽然这些都可以成为懒惰的理由，但是回顾一些自己这半年真的过于放松，许多学习的时间被游戏动漫日剧所占据，如果平时不用上班恐怕要变成废宅了吧╮(╯_╰)╭，so，确定一下今后的目标：<code>多写代码、多锻炼、多阅读、多写博客</code>，写博客主要为了思考，因为要在脑中整理语言，沉淀思想，一方面可以巩固记忆，另一方面也算是[热爱生活]的一种方式吧。</p>

<h2>好吧主题其实是</h2>

<p>其实有点为了写博客而写博客的意思，因为要分享的东西挺简单的，更像是吐槽……好吧其实我就是吐槽。</p>

<ul>
<li>吐槽1：微信支付为啥没有iOS的官方demo……实在想不通，服务端有，Android甚至WindowsPhone都有，微信这是对iOS平台歧视的节奏- &ndash;
幸好我大天朝人才辈出，早有人根据<code>渣成翔</code>的官方文档写了微信支付的<a href="https://github.com/gbammc/WechatPayDemo">非官方demo</a></li>
</ul>


<p>里面用了cocoapods， 需要下载的话好好看下说明。</p>

<ul>
<li>吐槽2：微信官方文档
虽然我知道，也理解 写代码的人一般比较讨厌写文档，但是毕竟你是一个支付组件，总有很多人需要仔细阅读的甚至copy文档里边的代码的，你可以写得很简单，但是不要犯一些低级错误好吗 (#‵′)。说明含糊不清我就不提了（其实上面的github主页有吐槽），实例代码都写错这就有点。。。
贴两段：</li>
</ul>


<p>``` objc</p>

<pre><code>PayReq *request = [[[PayReq alloc] init] autorelease]; 
request.partnerId = _pactnerid;
request.prepayId= _prapayid;
Request.package = _package;
request.nonceStr= _noncestr;
</code></pre>

<p>```</p>

<p>第三行好好的request突然变成Request了……当时看到整个人都不太好</p>

<p>And</p>

<p>``` objc</p>

<pre><code>// 构造参数列表
NSMutableDictionary params = [NSMutableDictionary dictionary]; 
[params setObject:@"1234567" forKey:@"appid"];
</code></pre>

<p>```</p>

<p>NSMutableDictionary params。。。原来NSMutableDictionary不是引用类型啊T.T</p>

<p>有些文档看了真的会哭。</p>

<ul>
<li>吐槽3：微信支付SDK</li>
</ul>


<p>处于安全便捷考虑，几乎所有的操作都在服务端完成，然后今天服务端给出API，也跟Android调通了。我本以为既然Android端都OK了，那iOS端应该也没多大问题……但是，我错了，我发现iOS端调用微信支付不成功，马上弹回原应用，拿到的是<code>errCode = -1</code>的错误。这些我就思密达了，然后一直在找是不是自己哪里调用不对。弄了一个多小时，未果。
然后很郁闷地吃了个饭，回去之后我跟服务端一步步联调……才发现问题出在PayReq的<code>sign</code>变量和<code>package</code>变量不对应。</p>

<p>再深入纠结原因，发现原来Android的文档或者SDK和iOS的处理是不一样的，而服务端是参考了Android的文档来做，我当场就呵呵了。
如果两端的处理方法不一样，至少也该说明一下吧。</p>

<hr />
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[我自己常常用到的第三方控件]]></title>
    <link href="http://KinoAndWorld.github.io/blog/2013/08/20/userful-third-controls/"/>
    <updated>2013-08-20T09:49:23+08:00</updated>
    <id>http://KinoAndWorld.github.io/blog/2013/08/20/userful-third-controls</id>
    <content type="html"><![CDATA[<ul>
<li>EGOTableViewPullRefresh（下拉刷新控件)
<a href="https://github.com/emreberge/EGOTableViewPullRefresh">Github地址</a></li>
</ul>


<p>只需要实现<code>PullTableViewDelegate</code>的这两个委托:</p>

<pre><code>- (void)pullTableViewDidTriggerRefresh:(PullTableView *)pullTableView
{
    [self performSelector:@selector(refreshTable) withObject:nil afterDelay:3.0f];
}

- (void)pullTableViewDidTriggerLoadMore:(PullTableView *)pullTableView
{
    [self performSelector:@selector(loadMoreDataToTable) withObject:nil afterDelay:3.0f];
}
</code></pre>

<p>这里面指向的具体方法是数据请求完成后进行处理和显示的操作，比如一般在里面reloadData之类：</p>

<pre><code>- (void) refreshTable
{
    /*
     Code to actually refresh goes here.
     */
    self.pullTableView.pullLastRefreshDate = [NSDate date];
    self.pullTableView.pullTableIsRefreshing = NO;
}

- (void) loadMoreDataToTable
{
    /*
     Code to actually load more data goes here.
     */
    self.pullTableView.pullTableIsLoadingMore = NO;
}
</code></pre>

<p>几乎就这么多，在注释部分进行逻辑处理，就好了。
注:这不是原版的，但我感觉是最完善的（上拉加载更多以及更自由的定制（背景颜色）等等），而且使用也更加简化。</p>

<ul>
<li>MMDrawerController(抽屉视图)
<a href="https://github.com/mutualmobile/MMDrawerController">Github地址</a></li>
</ul>


<p>抽屉式布局一直很火，应用也很广泛，相关控件也很多，感觉这个控件封装得比较好，而且功能也强大的很。
核心调用代码就几行：</p>

<pre><code>UIViewController * leftDrawer = [[UIViewController alloc] init];
UIViewController * center = [[UIViewController alloc] init];
UIViewController * rightDrawer = [[UIViewController alloc] init];
MMDrawerController * drawerController = [[MMDrawerController alloc]
                                       initWithCenterViewController:center
                                           leftDrawerViewController:leftDrawer
                                           rightDrawerViewController:rightDrawer];
</code></pre>

<p>其他的下载官方的demo。十分灰常详细。</p>

<ul>
<li>EGOImageView(异步加载图片)</li>
</ul>


<p>这个控件的使用非常简单，不用介绍过多~
而关于这个控件我有一篇专门的博客，可戳<a href="http://kinoandworld.github.io/2013/08/05/egoimage-addition/">这里</a></p>

<ul>
<li>PZPagingScrollView(延迟加载的滚动视图)
[额……地址暂时找不到了。]</li>
</ul>


<p>用这个控件可以很方便地做一个相册，提供的委托挺多的，有点类似UITableView委托的写法：</p>

<pre><code>- (Class)pagingScrollView:(PZPagingScrollView *)pagingScrollView classForIndex:(NSUInteger)index;
- (NSUInteger)pagingScrollViewPagingViewCount:(PZPagingScrollView *)pagingScrollView;
- (UIView *)pagingScrollView:(PZPagingScrollView *)pagingScrollView pageViewForIndex:(NSUInteger)index;
- (void)pagingScrollView:(PZPagingScrollView *)pagingScrollView preparePageViewForDisplay:(UIView *)pageView forIndex:(NSUInteger)index;
</code></pre>

<p>对这个控件我也做了一些修改，具体使用还是看例子吧。我都集成好放进一个demo里面了~</p>

<p>感兴趣的可以<a href="https://github.com/KinoAndWorld/UsefulThirdsControlsDemo">看看</a></p>
]]></content>
  </entry>
  
</feed>
