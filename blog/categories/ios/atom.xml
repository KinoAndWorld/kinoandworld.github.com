<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS | 奇诺の世界]]></title>
  <link href="http://KinoAndWorld.github.com/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://KinoAndWorld.github.com/"/>
  <updated>2014-03-23T02:13:44+08:00</updated>
  <id>http://KinoAndWorld.github.com/</id>
  <author>
    <name><![CDATA[Kino]]></name>
    <email><![CDATA[kinoandworld@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[我自己常常用到的第三方控件]]></title>
    <link href="http://KinoAndWorld.github.com/blog/2013/08/20/userful-third-controls/"/>
    <updated>2013-08-20T09:49:23+08:00</updated>
    <id>http://KinoAndWorld.github.com/blog/2013/08/20/userful-third-controls</id>
    <content type="html"><![CDATA[<ul>
<li>EGOTableViewPullRefresh（下拉刷新控件)
<a href="https://github.com/emreberge/EGOTableViewPullRefresh">Github地址</a></li>
</ul>


<p>只需要实现<code>PullTableViewDelegate</code>的这两个委托:</p>

<pre><code>- (void)pullTableViewDidTriggerRefresh:(PullTableView *)pullTableView
{
    [self performSelector:@selector(refreshTable) withObject:nil afterDelay:3.0f];
}

- (void)pullTableViewDidTriggerLoadMore:(PullTableView *)pullTableView
{
    [self performSelector:@selector(loadMoreDataToTable) withObject:nil afterDelay:3.0f];
}
</code></pre>

<p>这里面指向的具体方法是数据请求完成后进行处理和显示的操作，比如一般在里面reloadData之类：</p>

<pre><code>- (void) refreshTable
{
    /*
     Code to actually refresh goes here.
     */
    self.pullTableView.pullLastRefreshDate = [NSDate date];
    self.pullTableView.pullTableIsRefreshing = NO;
}

- (void) loadMoreDataToTable
{
    /*
     Code to actually load more data goes here.
     */
    self.pullTableView.pullTableIsLoadingMore = NO;
}
</code></pre>

<p>几乎就这么多，在注释部分进行逻辑处理，就好了。
注:这不是原版的，但我感觉是最完善的（上拉加载更多以及更自由的定制（背景颜色）等等），而且使用也更加简化。</p>

<ul>
<li>MMDrawerController(抽屉视图)
<a href="https://github.com/mutualmobile/MMDrawerController">Github地址</a></li>
</ul>


<p>抽屉式布局一直很火，应用也很广泛，相关控件也很多，感觉这个控件封装得比较好，而且功能也强大的很。
核心调用代码就几行：</p>

<pre><code>UIViewController * leftDrawer = [[UIViewController alloc] init];
UIViewController * center = [[UIViewController alloc] init];
UIViewController * rightDrawer = [[UIViewController alloc] init];
MMDrawerController * drawerController = [[MMDrawerController alloc]
                                       initWithCenterViewController:center
                                           leftDrawerViewController:leftDrawer
                                           rightDrawerViewController:rightDrawer];
</code></pre>

<p>其他的下载官方的demo。十分灰常详细。</p>

<ul>
<li>EGOImageView(异步加载图片)</li>
</ul>


<p>这个控件的使用非常简单，不用介绍过多~
而关于这个控件我有一篇专门的博客，可戳<a href="http://kinoandworld.github.io/2013/08/05/egoimage-addition/">这里</a></p>

<ul>
<li>PZPagingScrollView(延迟加载的滚动视图)
[额……地址暂时找不到了。]</li>
</ul>


<p>用这个控件可以很方便地做一个相册，提供的委托挺多的，有点类似UITableView委托的写法：</p>

<pre><code>- (Class)pagingScrollView:(PZPagingScrollView *)pagingScrollView classForIndex:(NSUInteger)index;
- (NSUInteger)pagingScrollViewPagingViewCount:(PZPagingScrollView *)pagingScrollView;
- (UIView *)pagingScrollView:(PZPagingScrollView *)pagingScrollView pageViewForIndex:(NSUInteger)index;
- (void)pagingScrollView:(PZPagingScrollView *)pagingScrollView preparePageViewForDisplay:(UIView *)pageView forIndex:(NSUInteger)index;
</code></pre>

<p>对这个控件我也做了一些修改，具体使用还是看例子吧。我都集成好放进一个demo里面了~</p>

<p>感兴趣的可以<a href="https://github.com/KinoAndWorld/UsefulThirdsControlsDemo">看看</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[给EGOImageView增加下载进度功能]]></title>
    <link href="http://KinoAndWorld.github.com/blog/2013/08/05/egoimage-addition/"/>
    <updated>2013-08-05T09:49:23+08:00</updated>
    <id>http://KinoAndWorld.github.com/blog/2013/08/05/egoimage-addition</id>
    <content type="html"><![CDATA[<h3>给EGOImageView异步加载图片增加下载进度功能</h3>

<p>&mdash;</p>

<p>做网络图片相关的项目时，离不开缓存和异步加载。于是找到了一个很好用的第三方控件
 <a href="https://github.com/enormego/EGOImageLoading">EGOImageView</a></p>

<p>灰常简单好用~</p>

<p>但是呢，随着项目的进一步展开，弱弱地发现这个控件并没有<code>获取图片加载进度</code>这么个功能，而且一般我们等待图片加载时需要有一个显示进度的进度条，这样就无法实现了。</p>

<p>于是我上网找到了获取进度的方法，然后自己改造了一下EGOImageView，写这篇博客，仅做一下记录。</p>

<h3>首先，找到EGOImageLoadConnection这个类</h3>

<p>在它的.h文件加上下面两个自定义的委托</p>

<pre><code>@protocol EGOImageLoadConnectionDelegate&lt;NSObject&gt;
- (void)imageLoadConnectionDidFinishLoading:(EGOImageLoadConnection *)connection;
- (void)imageLoadConnection:(EGOImageLoadConnection *)connection didFailWithError:(NSError *)error;
//进度委托
- (void)imageLoadConnection:(EGOImageLoadConnection *)connection didDownLoadData:(long long)btyes;
- (void)imageLoadConnection:(EGOImageLoadConnection *)connection countDownLoadData:(long long)btyes;
@end
</code></pre>

<p>紧接着，进入.m文件，找到这两个方法，这两个方法是关键。</p>

<pre><code>didReceiveResponse是得到一个有效图片URL后返回的信息，里面就包含了图片的大小
didReceiveData则是在一张图片下载过程中，不断传输过来的数据，因此这个方法可能会调用不止一次

- (void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data {
    if(connection != _connection) return;
    [_responseData appendData:data];
}

- (void)connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response {
    if(connection != _connection) return;
    self.response = response;
}
</code></pre>

<p>网上找了方法，加进去，变成下面这样</p>

<pre><code>- (void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data {
    if(connection != _connection) return;
    [_responseData appendData:data];
    //NSLog(@"%lld",(long long)[data length]);
    if([self.delegate respondsToSelector:@selector(imageLoadConnection:didDownLoadData:)]) {
        [self.delegate imageLoadConnection:self didDownLoadData:(long long)[data length]];
    }
}

- (void)connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response {

    long long total_;
    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *)response;
    if(httpResponse &amp;&amp; [httpResponse respondsToSelector:@selector(allHeaderFields)]){
        NSDictionary *httpResponseHeaderFields = [httpResponse allHeaderFields];

        total_ = [[httpResponseHeaderFields objectForKey:@"Content-Length"] longLongValue];
        if([self.delegate respondsToSelector:@selector(imageLoadConnection:countDownLoadData:)]) {
            [self.delegate imageLoadConnection:self countDownLoadData:total_];
        }
        //NSLog(@"total:%lld", total_);
    }
    if(connection != _connection) return;
    self.response = response;
}
</code></pre>

<p>理论上，现在已经获取到了数据的大小和每次传输的数据量，接着进入EGOImageLoader.m文件。
然后我遵循它原本的模式（观察者），添加两个宏定义:</p>

<pre><code>#if __EGOIL_USE_NOTIF
    #define kImageNotificationLoaded(s) [@"kEGOImageLoaderNotificationLoaded-" stringByAppendingString:keyForURL(s, nil)]
    #define kImageNotificationLoadFailed(s) [@"kEGOImageLoaderNotificationLoadFailed-" stringByAppendingString:keyForURL(s, nil)]
    //下载进度
    #define kImageNotificationLoadData(s) [@"kEGOImageLoaderNotificationLoadedData-" stringByAppendingString:keyForURL(s, nil)]
    #define kImageNotificationCountLoadData(s) [@"kEGOImageLoaderNotificationCountLoadData-" stringByAppendingString:keyForURL(s, nil)]
#endif
</code></pre>

<p>接着同样在 <code>-(void)loadImageForURL:(NSURL*)aURL observer:(id&lt;EGOImageLoaderObserver&gt;)observer;</code>
方法添加观察者</p>

<pre><code>//进度的观察
if([observer respondsToSelector:@selector(imageLoaderDidLoadData:)]) {
    [[NSNotificationCenter defaultCenter] addObserver:observer selector:@selector(imageLoaderDidLoadData:) name:kImageNotificationLoadData(aURL) object:self];
}
if([observer respondsToSelector:@selector(imageLoaderDidCountLoadData:)]) {
    [[NSNotificationCenter defaultCenter] addObserver:observer selector:@selector(imageLoaderDidCountLoadData:) name:kImageNotificationCountLoadData(aURL) object:self];
}
</code></pre>

<p>和在 <code>-(void)removeObserver:(id&lt;EGOImageLoaderObserver&gt;)observer forURL:(NSURL*)aURL;</code>
方法删除观察者</p>

<pre><code>// 移除下载进度观察者
[[NSNotificationCenter defaultCenter] removeObserver:observer name:kImageNotificationCountLoadData(aURL) object:self];
[[NSNotificationCenter defaultCenter] removeObserver:observer name:kImageNotificationLoadData(aURL) object:self];
</code></pre>

<p>接着，该实现刚刚写的那两个委托了</p>

<pre><code>#pragma mark URL Connection delegate methods
//下载进度
- (void)imageLoadConnection:(EGOImageLoadConnection *)connection didDownLoadData:(long long)btyes{
#if __EGOIL_USE_NOTIF
    NSNotification* notification = [NSNotification notificationWithName:kImageNotificationLoadData(connection.imageURL)
                                                                 object:self
                                                               userInfo:[NSDictionary dictionaryWithObjectsAndKeys:
                                                                         [NSNumber numberWithLongLong:btyes],@"btyes",
                                                                         connection.imageURL,@"imageURL",nil]];

    [[NSNotificationCenter defaultCenter] performSelectorOnMainThread:@selector(postNotification:) withObject:notification waitUntilDone:YES];
#endif
}

- (void)imageLoadConnection:(EGOImageLoadConnection *)connection countDownLoadData:(long long)btyes{
#if __EGOIL_USE_NOTIF
    NSNotification* notification = [NSNotification notificationWithName:kImageNotificationCountLoadData(connection.imageURL)
                                                                 object:self
                                                               userInfo:[NSDictionary dictionaryWithObjectsAndKeys:
                                                                         [NSNumber numberWithLongLong:btyes],@"btyes",
                                                                         connection.imageURL,@"imageURL",nil]];

    [[NSNotificationCenter defaultCenter] performSelectorOnMainThread:@selector(postNotification:) withObject:notification waitUntilDone:YES];
#endif
}
</code></pre>

<p>最后呢，我们再给EGOImageView.h文件加两个委托</p>

<pre><code>//图片进度
- (void)imageViewImageProgress:(long long)bytes;
- (void)imageViewImageProgressCount:(long long)bytes;
</code></pre>

<p>还记得我刚刚加的两个通知么，现在派上用场了，在.m文件加上如下代码</p>

<pre><code>//进度处理
- (void)imageLoaderDidLoadData:(NSNotification*)notification {
    if(![[[notification userInfo] objectForKey:@"imageURL"] isEqual:self.imageURL]) return;
    long long bytes = [[[notification userInfo] objectForKey:@"btyes"] longLongValue];

    //NSLog(@"sub:%lld",bytes);
    if([self.delegate respondsToSelector:@selector(imageViewImageProgress:)]) {
        [self.delegate imageViewImageProgress:bytes];
    }
}

- (void)imageLoaderDidCountLoadData:(NSNotification*)notification {

    if(![[[notification userInfo] objectForKey:@"imageURL"] isEqual:self.imageURL]) return;
    long long bytes = [[[notification userInfo] objectForKey:@"btyes"] longLongValue];

    if([self.delegate respondsToSelector:@selector(imageViewImageProgressCount:)]) {
        [self.delegate imageViewImageProgressCount:bytes];
    }
}
</code></pre>

<p>大功告成。
<img src="" /></p>
]]></content>
  </entry>
  
</feed>
